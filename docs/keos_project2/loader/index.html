<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ELF Loading."><title>keos_project2::loader - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="keos_project2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (425a9c0a0 2025-08-17)" data-channel="nightly" data-search-js="search-b069538f.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../keos_project2/index.html">keos_<wbr>project2</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module loader</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#elf-loading" title="ELF Loading.">ELF Loading.</a></li><li><a href="#state-on-program-startup" title="State on Program Startup">State on Program Startup</a><ul><li><a href="#launching-a-process" title="Launching a Process">Launching a Process</a></li></ul></li><li><a href="#implementation-requirements" title="Implementation Requirements">Implementation Requirements</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate keos_<wbr>project2</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">keos_project2</a></div><h1>Module <span>loader</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/keos_project2/loader/mod.rs.html#1-282">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h3 id="elf-loading"><a class="doc-anchor" href="#elf-loading">§</a>ELF Loading.</h3>
<p>When you run a program on a modern operating system, the kernel needs to
know <strong>how to take the program stored on disk and place it into memory so it
can start running</strong>. The file format that describes this mapping is called
<strong>ELF (Executable and Linkable Format)</strong>.</p>
<p><img src="https://casys-kaist.github.io/KeOS/images/loader.png" alt="ELF" /></p>
<p>Think of ELF as a “blueprint” for a program’s memory layout. It tells the
kernel where each part of the program (code, data, uninitialized variables)
should go in memory, what permissions they need (read, write, execute), and
where the program should begin execution.</p>
<p>An ELF file contains:</p>
<ul>
<li><strong>ELF header</strong> – a small table of contents that points to the rest of the
file and gives the program’s entry point (where execution starts).</li>
<li><strong>Program headers</strong> – a list of <strong>segments</strong>, each describing a chunk of
the file that should be loaded into memory.</li>
</ul>
<p>In KeOS, we only care about the <strong>program headers</strong>, because they tell us
how to build the process’s memory image. Each program header (<code>Phdr</code>) says:</p>
<ul>
<li><strong>Virtual address</strong> (<a href="elf/struct.Phdr.html#structfield.p_vaddr" title="field keos_project2::loader::elf::Phdr::p_vaddr"><code>Phdr::p_vaddr</code></a>) – Where in memory they should go.</li>
<li><strong>Memory size</strong> (<a href="elf/struct.Phdr.html#structfield.p_memsz" title="field keos_project2::loader::elf::Phdr::p_memsz"><code>Phdr::p_memsz</code></a>) – How big the memory region should be
in total.</li>
<li><strong>File size</strong> (<a href="elf/struct.Phdr.html#structfield.p_filesz" title="field keos_project2::loader::elf::Phdr::p_filesz"><code>Phdr::p_filesz</code></a>) – How many bytes come from the file.</li>
<li><strong>File offset</strong> (<a href="elf/struct.Phdr.html#structfield.p_offset" title="field keos_project2::loader::elf::Phdr::p_offset"><code>Phdr::p_offset</code></a>) - Where in the file the bytes are
stored.</li>
<li><strong>Permissions</strong> (<a href="elf/struct.Phdr.html#structfield.p_flags" title="field keos_project2::loader::elf::Phdr::p_flags"><code>Phdr::p_flags</code></a>) – What permissions the region needs.</li>
</ul>
<p>You can iterate through the <a href="elf/struct.Phdr.html" title="struct keos_project2::loader::elf::Phdr"><code>Phdr</code></a>s with <a href="elf/struct.Elf.html#method.phdrs" title="method keos_project2::loader::elf::Elf::phdrs"><code>Elf::phdrs()</code></a>, which returns
an iterator over <a href="elf/struct.Phdr.html" title="struct keos_project2::loader::elf::Phdr"><code>Phdr</code></a> entries. The most important type of header is
<a href="elf/enum.PType.html#variant.Load" title="variant keos_project2::loader::elf::PType::Load"><code>PType::Load</code></a>, meaning “this segment must be loaded into memory.” To load
it, KeOS does the following:</p>
<ol>
<li>Allocate memory at the given virtual address using <a href="../mm_struct/struct.MmStruct.html#method.do_mmap" title="method keos_project2::mm_struct::MmStruct::do_mmap"><code>MmStruct::do_mmap</code></a>.</li>
<li>Copy <code>filesz</code> bytes from the ELF file (starting at <code>p_offset</code>) into that
memory.</li>
<li>If <code>memsz &gt; filesz</code>, fill the extra space with zeros — this is how ELF
represents the <strong><code>.bss</code> section</strong>, which holds uninitialized global
variables.</li>
</ol>
<p>By repeating this for every loadable segment, the kernel reconstructs the
program’s expected memory image: code in <code>.text</code>, constants in <code>.rodata</code>,
variables in <code>.data</code>, and zero-initialized memory in <code>.bss</code>. When this is
done, the program’s virtual memory matches exactly what the compiler and
linker prepared, and the kernel can safely jump to the entry point to start
execution.</p>
<p>There are some pitfalls while loding a ELF:</p>
<ul>
<li><code>p_vaddr</code> must be page-aligned. If not, round it down and adjust offsets
accordingly.</li>
<li>Ensure segments do not overwrite existing mappings like the stack or
kernel memory.</li>
</ul>
<h3 id="state-on-program-startup"><a class="doc-anchor" href="#state-on-program-startup">§</a>State on Program Startup</h3>
<p>The KeOS user-space C library (<code>kelibc</code>) defines <code>_start()</code>, located in
<code>kelibc/entry.c</code>, as the program entry point. It calls <code>main()</code> and
exits when <code>main()</code> returns. The kernel must set up the registers and user
program’s stack correctly before execution, passing arguments according to
the standard calling convention. [<code>Registers</code>] contains the CPU states on
launching a program, including instruction pointer, stack pointer, and
general-purpose registers.</p>
<p><strong>Example command:</strong> <code>/bin/ls -l foo bar</code></p>
<ol>
<li>Split the command into words: <code>"/bin/ls"</code>, <code>"-l"</code>, <code>"foo"</code>, <code>"bar"</code>.</li>
<li>Copy the argument strings to the top of the stack (order does not
matter).</li>
<li>Push their addresses, followed by a null sentinel (<code>argv[argc] = NULL</code>).
<ul>
<li>Align the stack pointer to an 8-byte boundary for performance.</li>
</ul>
</li>
<li>Set <code>%rdi = argc</code> (argument count) and <code>%rsi = argv</code> (argument array).</li>
<li>Push a fake return address to maintain stack integrity.</li>
</ol>
<p><strong>Example stack layout before execution:</strong></p>
<div><table><thead><tr><th>Address</th><th>Name</th><th>Data</th><th>Type</th></tr></thead><tbody>
<tr><td>0x4747fffc</td><td>argv[3][…]</td><td>‘bar\0’</td><td>char[4]</td></tr>
<tr><td>0x4747fff8</td><td>argv[2][…]</td><td>‘foo\0’</td><td>char[4]</td></tr>
<tr><td>0x4747fff5</td><td>argv[1][…]</td><td>‘-l\0’</td><td>char[3]</td></tr>
<tr><td>0x4747ffed</td><td>argv[0][…]</td><td>‘/bin/ls\0’</td><td>char[8]</td></tr>
<tr><td>0x4747ffe8</td><td>word-align</td><td>0</td><td>uint8_t[]</td></tr>
<tr><td>0x4747ffe0</td><td>argv[4]</td><td>0</td><td>char *</td></tr>
<tr><td>0x4747ffd8</td><td>argv[3]</td><td>0x4747fffc</td><td>char *</td></tr>
<tr><td>0x4747ffd0</td><td>argv[2]</td><td>0x4747fff8</td><td>char *</td></tr>
<tr><td>0x4747ffc8</td><td>argv[1]</td><td>0x4747fff5</td><td>char *</td></tr>
<tr><td>0x4747ffc0</td><td>argv[0]</td><td>0x4747ffed</td><td>char *</td></tr>
<tr><td>0x4747ffb8</td><td>return address</td><td>0</td><td>void (*) ()</td></tr>
</tbody></table>
</div>
<p>The stack pointer (<code>rsp</code>) is initialized to <code>0x4747ffb8</code>. The first two
arguments, <code>%rdi</code> and <code>%rsi</code>, should be <code>4</code> and <code>0x4747ffc0</code>, respectively.
The user program stack always starts at <code>0x47480000</code> in KeOS, and always
grows downward.</p>
<p><a href="stack_builder/struct.StackBuilder.html" title="struct keos_project2::loader::stack_builder::StackBuilder"><code>StackBuilder</code></a> is a utility for constructing user-space stacks. It
provides:</p>
<ul>
<li><a href="stack_builder/struct.StackBuilder.html#method.push_usize" title="method keos_project2::loader::stack_builder::StackBuilder::push_usize"><code>StackBuilder::push_usize</code></a> – Pushes a <code>usize</code> value (e.g., pointers like
<code>argv[]</code>).</li>
<li><a href="stack_builder/struct.StackBuilder.html#method.push_str" title="method keos_project2::loader::stack_builder::StackBuilder::push_str"><code>StackBuilder::push_str</code></a> – Pushes a null-terminated string and returns
its address.</li>
<li><a href="stack_builder/struct.StackBuilder.html#method.align" title="method keos_project2::loader::stack_builder::StackBuilder::align"><code>StackBuilder::align</code></a> – Aligns the stack pointer for proper memory
access.</li>
</ul>
<p>You can use these methods to set up the stack in
<a href="struct.LoadContext.html#method.build_stack" title="method keos_project2::loader::LoadContext::build_stack"><code>LoadContext::build_stack</code></a>.</p>
<h5 id="launching-a-process"><a class="doc-anchor" href="#launching-a-process">§</a>Launching a Process</h5>
<p>After loading the program in memory and setting up the stack, the kernel
switches to user mode and begin execution. This is done using
<a href="../../keos/syscall/struct.Registers.html#method.launch"><code>Registers::launch</code></a>. Calling <a href="../../keos/syscall/struct.Registers.html#method.launch"><code>Registers::launch</code></a> causes the CPU to
change the privilege level to user mode and start executing from <code>rip</code>. You
don’t need to implement this functionality as it is already implemented in
the outside of this module.</p>
<h3 id="implementation-requirements"><a class="doc-anchor" href="#implementation-requirements">§</a>Implementation Requirements</h3>
<p>You need to implement the followings:</p>
<ul>
<li><a href="elf/struct.Phdr.html#method.permission" title="method keos_project2::loader::elf::Phdr::permission"><code>Phdr::permission</code></a></li>
<li><a href="stack_builder/struct.StackBuilder.html#method.push_bytes" title="method keos_project2::loader::stack_builder::StackBuilder::push_bytes"><code>StackBuilder::push_bytes</code></a></li>
<li><a href="struct.LoadContext.html#method.load_phdr" title="method keos_project2::loader::LoadContext::load_phdr"><code>LoadContext::load_phdr</code></a></li>
<li><a href="struct.LoadContext.html#method.build_stack" title="method keos_project2::loader::LoadContext::build_stack"><code>LoadContext::build_stack</code></a></li>
</ul>
<p>This ends the project 2.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="elf/index.html" title="mod keos_project2::loader::elf">elf</a></dt><dd>Utility to parsing ELF file.</dd><dt><a class="mod" href="stack_builder/index.html" title="mod keos_project2::loader::stack_builder">stack_<wbr>builder</a></dt><dd><a href="stack_builder/struct.StackBuilder.html" title="struct keos_project2::loader::stack_builder::StackBuilder"><code>StackBuilder</code></a>, a utility for constructing a user-space stack layout.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.LoadContext.html" title="struct keos_project2::loader::LoadContext">Load<wbr>Context</a></dt><dd>A context that holds the necessary state for loading and initializing a user
program.</dd></dl></section></div></main></body></html>