<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/cskwak99/new-cs330-project.code/keos/abyss/src/dev/pci/virtio/tys.rs`."><title>tys.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="abyss" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../../static.files/storage-e2aeef58.js"></script><script defer src="../../../../../static.files/src-script-813739b1.js"></script><script defer src="../../../../../src-files.js"></script><script defer src="../../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">abyss/dev/pci/virtio/</div>tys.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap digits-3"><pre class="rust"><code><a href=#1 id=1 data-nosnippet>1</a><span class="doccomment">/// Device Types.
<a href=#2 id=2 data-nosnippet>2</a>///
<a href=#3 id=3 data-nosnippet>3</a>/// On top of the queues, config space and feature negotiation facilities built
<a href=#4 id=4 data-nosnippet>4</a>/// into virtio, several devices are defined. The following device IDs are used
<a href=#5 id=5 data-nosnippet>5</a>/// to identify different types of virtio devices. Some device IDs are reserved
<a href=#6 id=6 data-nosnippet>6</a>/// for devices which are not currently defined in this standard. Discovering
<a href=#7 id=7 data-nosnippet>7</a>/// what devices are available and their type is bus-dependent.
<a href=#8 id=8 data-nosnippet>8</a></span><span class="attr">#[repr(u32)]
<a href=#9 id=9 data-nosnippet>9</a>#[allow(dead_code)]
<a href=#10 id=10 data-nosnippet>10</a>#[derive(Debug, num_enum::TryFromPrimitive)]
<a href=#11 id=11 data-nosnippet>11</a></span><span class="kw">pub enum </span>DeviceType {
<a href=#12 id=12 data-nosnippet>12</a>    Reserved = <span class="number">0</span>,
<a href=#13 id=13 data-nosnippet>13</a>    NetworkCard = <span class="number">1</span>,
<a href=#14 id=14 data-nosnippet>14</a>    Block = <span class="number">2</span>,
<a href=#15 id=15 data-nosnippet>15</a>    Console = <span class="number">3</span>,
<a href=#16 id=16 data-nosnippet>16</a>    EntropySource = <span class="number">4</span>,
<a href=#17 id=17 data-nosnippet>17</a>    MemoryBallonningTranditional = <span class="number">5</span>,
<a href=#18 id=18 data-nosnippet>18</a>    IoMemory = <span class="number">6</span>,
<a href=#19 id=19 data-nosnippet>19</a>    RpMsg = <span class="number">7</span>,
<a href=#20 id=20 data-nosnippet>20</a>    ScsiHost = <span class="number">8</span>,
<a href=#21 id=21 data-nosnippet>21</a>    Transport9P = <span class="number">9</span>,
<a href=#22 id=22 data-nosnippet>22</a>    Mac802WLan = <span class="number">10</span>,
<a href=#23 id=23 data-nosnippet>23</a>    RprocSerial = <span class="number">11</span>,
<a href=#24 id=24 data-nosnippet>24</a>    VirtioCaif = <span class="number">12</span>,
<a href=#25 id=25 data-nosnippet>25</a>    MemoryBalloon = <span class="number">13</span>,
<a href=#26 id=26 data-nosnippet>26</a>    Gpu = <span class="number">16</span>,
<a href=#27 id=27 data-nosnippet>27</a>    TimerClock = <span class="number">17</span>,
<a href=#28 id=28 data-nosnippet>28</a>    Input = <span class="number">18</span>,
<a href=#29 id=29 data-nosnippet>29</a>    Socket = <span class="number">19</span>,
<a href=#30 id=30 data-nosnippet>30</a>    Crypto = <span class="number">20</span>,
<a href=#31 id=31 data-nosnippet>31</a>    SignalDistributionModule = <span class="number">21</span>,
<a href=#32 id=32 data-nosnippet>32</a>    Pstore = <span class="number">22</span>,
<a href=#33 id=33 data-nosnippet>33</a>    IoMmu = <span class="number">23</span>,
<a href=#34 id=34 data-nosnippet>34</a>    Memory = <span class="number">24</span>,
<a href=#35 id=35 data-nosnippet>35</a>}
<a href=#36 id=36 data-nosnippet>36</a>
<a href=#37 id=37 data-nosnippet>37</a><span class="macro">bitflags::bitflags!</span> {
<a href=#38 id=38 data-nosnippet>38</a>    <span class="doccomment">/// VirtIo Device Status.
<a href=#39 id=39 data-nosnippet>39</a>    </span><span class="attr">#[repr(transparent)]
<a href=#40 id=40 data-nosnippet>40</a>    </span><span class="kw">pub struct </span>Status: u8 {
<a href=#41 id=41 data-nosnippet>41</a>        <span class="doccomment">/// Indicates that the guest OS has found the device and recognized it
<a href=#42 id=42 data-nosnippet>42</a>        /// as a valid virtio device.
<a href=#43 id=43 data-nosnippet>43</a>        </span><span class="kw">const </span>ACKNOWLEDGE = <span class="number">1 </span>&lt;&lt; <span class="number">0</span>;
<a href=#44 id=44 data-nosnippet>44</a>        <span class="doccomment">/// Indicates that the guest OS knows how to drive the device.
<a href=#45 id=45 data-nosnippet>45</a>        ///
<a href=#46 id=46 data-nosnippet>46</a>        /// Note: There could be a significant (or infinite) delay before
<a href=#47 id=47 data-nosnippet>47</a>        /// setting this bit. For example, under Linux, drivers can be loadable
<a href=#48 id=48 data-nosnippet>48</a>        /// modules.
<a href=#49 id=49 data-nosnippet>49</a>        </span><span class="kw">const </span>DRIVER = <span class="number">1 </span>&lt;&lt; <span class="number">1</span>;
<a href=#50 id=50 data-nosnippet>50</a>        <span class="doccomment">/// Indicates that the driver is set up and ready to drive the device.
<a href=#51 id=51 data-nosnippet>51</a>        </span><span class="kw">const </span>DRIVER_OK = <span class="number">1 </span>&lt;&lt; <span class="number">2</span>;
<a href=#52 id=52 data-nosnippet>52</a>        <span class="doccomment">/// Indicates that the driver has acknowledged all the features it
<a href=#53 id=53 data-nosnippet>53</a>        /// understands, and feature negotiation is complete.
<a href=#54 id=54 data-nosnippet>54</a>        </span><span class="kw">const </span>FEATURES_OK = <span class="number">1 </span>&lt;&lt; <span class="number">3</span>;
<a href=#55 id=55 data-nosnippet>55</a>        <span class="doccomment">/// Indicates that the device has experienced an error from which it
<a href=#56 id=56 data-nosnippet>56</a>        /// can't recover.
<a href=#57 id=57 data-nosnippet>57</a>        </span><span class="kw">const </span>DEVICE_NEEDS_RESET = <span class="number">1 </span>&lt;&lt; <span class="number">6</span>;
<a href=#58 id=58 data-nosnippet>58</a>        <span class="doccomment">/// Indicates that something went wrong in the guest, and it has given
<a href=#59 id=59 data-nosnippet>59</a>        /// up on the device. This could be an internal error, or the driver
<a href=#60 id=60 data-nosnippet>60</a>        /// didn't like the device for some reason, or even a fatal error during
<a href=#61 id=61 data-nosnippet>61</a>        /// device operation.
<a href=#62 id=62 data-nosnippet>62</a>        </span><span class="kw">const </span>FAILED = <span class="number">1 </span>&lt;&lt; <span class="number">7</span>;
<a href=#63 id=63 data-nosnippet>63</a>    }
<a href=#64 id=64 data-nosnippet>64</a>}
<a href=#65 id=65 data-nosnippet>65</a>
<a href=#66 id=66 data-nosnippet>66</a><span class="macro">bitflags::bitflags!</span> {
<a href=#67 id=67 data-nosnippet>67</a>    <span class="kw">pub struct </span>VirtIoFeaturesCommon: u64 {
<a href=#68 id=68 data-nosnippet>68</a>        <span class="comment">// 6.3 Legacy
<a href=#69 id=69 data-nosnippet>69</a>        </span><span class="doccomment">/// If this feature has been negotiated by driver, the device MUST issue a used buffer notification if the device runs out of available descriptors on a virtqueue, even though notifications are suppressed using the VIRTQ_AVAIL_F_NO_INTERRUPT flag or the used_event field. Note: An example of a driver using this feature is the legacy networking driver: it doesnâ€™t need to know every time a packet is transmitted, but it does need to free the transmitted packets a finite time after they are transmitted. It can avoid using a timer if the device notifies it when all the packets are transmitted.
<a href=#70 id=70 data-nosnippet>70</a>        </span><span class="kw">const </span>NOTIFY_ON_EMPTY = <span class="number">1 </span>&lt;&lt; <span class="number">24</span>;
<a href=#71 id=71 data-nosnippet>71</a>        <span class="doccomment">/// This feature indicates that the device accepts arbitrary descriptor layouts, as described in Section 2.6.4.3 Legacy Interface: Message Framing.
<a href=#72 id=72 data-nosnippet>72</a>        </span><span class="kw">const </span>ANY_LAYOUT = <span class="number">1 </span>&lt;&lt; <span class="number">27</span>;
<a href=#73 id=73 data-nosnippet>73</a>
<a href=#74 id=74 data-nosnippet>74</a>        <span class="comment">// 6. Reserved Feature Bits
<a href=#75 id=75 data-nosnippet>75</a>        </span><span class="doccomment">/// Negotiating this feature indicates that the driver can use descriptors with the VIRTQ_DESC_F_INDIRECT flag set, as described in 2.6.5.3 Indirect Descriptors and 2.7.7 Indirect Flag: Scatter-Gather Support.
<a href=#76 id=76 data-nosnippet>76</a>        </span><span class="kw">const </span>RING_INDIRECT_DESC = <span class="number">1 </span>&lt;&lt; <span class="number">28</span>;
<a href=#77 id=77 data-nosnippet>77</a>        <span class="doccomment">/// This feature enables the used_event and the avail_event fields as described in 2.6.7, 2.6.8 and 2.7.10.
<a href=#78 id=78 data-nosnippet>78</a>        </span><span class="kw">const </span>RING_EVENT_IDX = <span class="number">1 </span>&lt;&lt; <span class="number">29</span>;
<a href=#79 id=79 data-nosnippet>79</a>        <span class="doccomment">/// This indicates compliance with this specification, giving a simple way to detect legacy devices or drivers.
<a href=#80 id=80 data-nosnippet>80</a>        </span><span class="kw">const </span>VERSION_1 = <span class="number">1 </span>&lt;&lt; <span class="number">32</span>;
<a href=#81 id=81 data-nosnippet>81</a>        <span class="doccomment">/// This feature indicates that the device can be used on a platform where device access to data in memory is limited and/or translated. E.g. this is the case if the device can be located behind an IOMMU that translates bus addresses from the device into physical addresses in memory, if the device can be limited to only access certain memory addresses or if special commands such as a cache flush can be needed to synchronise data in memory with the device. Whether accesses are actually limited or translated is described by platform-specific means. If this feature bit is set to 0, then the device has same access to memory addresses supplied to it as the driver has. In particular, the device will always use physical addresses matching addresses used by the driver (typically meaning physical addresses used by the CPU) and not translated further, and can access any address supplied to it by the driver. When clear, this overrides any platform-specific description of whether device access is limited or translated in any way, e.g. whether an IOMMU may be present.
<a href=#82 id=82 data-nosnippet>82</a>        </span><span class="kw">const </span>ACCESS_PLATFORM = <span class="number">1 </span>&lt;&lt; <span class="number">33</span>;
<a href=#83 id=83 data-nosnippet>83</a>        <span class="doccomment">/// This feature indicates support for the packed virtqueue layout as described in 2.7 Packed Virtqueues.
<a href=#84 id=84 data-nosnippet>84</a>        </span><span class="kw">const </span>RING_PACKED = <span class="number">1 </span>&lt;&lt; <span class="number">34</span>;
<a href=#85 id=85 data-nosnippet>85</a>        <span class="doccomment">/// This feature indicates that all buffers are used by the device in the same order in which they have been made available.
<a href=#86 id=86 data-nosnippet>86</a>        </span><span class="kw">const </span>IN_ORDER = <span class="number">1 </span>&lt;&lt; <span class="number">35</span>;
<a href=#87 id=87 data-nosnippet>87</a>        <span class="doccomment">/// This feature indicates that memory accesses by the driver and the device are ordered in a way described by the platform. If this feature bit is negotiated, the ordering in effect for any memory accesses by the driver that need to be ordered in a specific way with respect to accesses by the device is the one suitable for devices described by the platform. This implies that the driver needs to use memory barriers suitable for devices described by the platform; e.g. for the PCI transport in the case of hardware PCI devices.
<a href=#88 id=88 data-nosnippet>88</a>        ///  this feature bit is not negotiated, then the device and driver are assumed to be implemented in software, that is they can be assumed to run on identical CPUs in an SMP configuration. Thus a weaker form of memory barriers is sufficient to yield better performance.
<a href=#89 id=89 data-nosnippet>89</a>        </span><span class="kw">const </span>ORDER_PLATFORM = <span class="number">1 </span>&lt;&lt; <span class="number">36</span>;
<a href=#90 id=90 data-nosnippet>90</a>        <span class="doccomment">/// This feature indicates that the device supports Single Root I/O Virtualization. Currently only PCI devices support this feature.
<a href=#91 id=91 data-nosnippet>91</a>        </span><span class="kw">const </span>SR_IOV = <span class="number">1 </span>&lt;&lt; <span class="number">37</span>;
<a href=#92 id=92 data-nosnippet>92</a>        <span class="doccomment">/// This feature indicates that the driver passes extra data (besides identifying the virtqueue) in its device notifications. See 2.7.23 Driver notifications.
<a href=#93 id=93 data-nosnippet>93</a>        </span><span class="kw">const </span>NOTRIFICATION_DATA = <span class="number">1 </span>&lt;&lt; <span class="number">38</span>;
<a href=#94 id=94 data-nosnippet>94</a>    }
<a href=#95 id=95 data-nosnippet>95</a>}
<a href=#96 id=96 data-nosnippet>96</a>
<a href=#97 id=97 data-nosnippet>97</a><span class="macro">bitflags::bitflags!</span> {
<a href=#98 id=98 data-nosnippet>98</a>    <span class="kw">pub struct </span>IsrCfg: u32 {
<a href=#99 id=99 data-nosnippet>99</a>        <span class="kw">const </span>QUEUE_INTERRUPT = <span class="number">1 </span>&lt;&lt; <span class="number">0</span>;
<a href=#100 id=100 data-nosnippet>100</a>        <span class="kw">const </span>DEVICE_CONFIGURATION_INTERRUPT = <span class="number">1 </span>&lt;&lt; <span class="number">1</span>;
<a href=#101 id=101 data-nosnippet>101</a>    }
<a href=#102 id=102 data-nosnippet>102</a>}</code></pre></div></section></main></body></html>