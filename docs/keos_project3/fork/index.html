<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`Fork` with Copy-On-Write optimization."><title>keos_project3::fork - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="keos_project3" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (425a9c0a0 2025-08-17)" data-channel="nightly" data-search-js="search-b069538f.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../keos_project3/index.html">keos_<wbr>project3</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module fork</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#fork-with-copy-on-write-optimization" title="`Fork` with Copy-On-Write optimization."><code>Fork</code> with Copy-On-Write optimization.</a><ul><li><a href="#copy-on-write" title="Copy-On-Write">Copy-On-Write</a></li><li><a href="#implementation-requirements" title="Implementation Requirements">Implementation Requirements</a></li></ul></li></ul><h3><a href="#functions">Module Items</a></h3><ul class="block"><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate keos_<wbr>project3</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">keos_project3</a></div><h1>Module <span>fork</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/keos_project3/fork.rs.html#1-213">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="fork-with-copy-on-write-optimization"><a class="doc-anchor" href="#fork-with-copy-on-write-optimization">§</a><code>Fork</code> with Copy-On-Write optimization.</h2>
<p><code>fork</code> is a system call that creates a new process by duplicating the
calling process. The new child process is almost identical to the parent,
inheriting the same memory layout, open file descriptors, and register
state. The child receives a copy of the parent’s process state, including
<a href="../../keos_project1/file_struct/struct.FileStruct.html" title="struct keos_project1::file_struct::FileStruct"><code>FileStruct</code></a> and <a href="../../keos_project2/mm_struct/struct.MmStruct.html" title="struct keos_project2::mm_struct::MmStruct"><code>MmStruct</code></a>. Two processes can communicate via opened
<code>pipe</code>s after the forking. The only difference is the return value of
the syscall: the parent receives the child’s PID, while the child receives
0.</p>
<h4 id="copy-on-write"><a class="doc-anchor" href="#copy-on-write">§</a>Copy-On-Write</h4>
<p>In modern operating system, <strong>fork</strong> utilizes <strong>copy-on-write (COW)</strong>
optimization to efficiently share memory between parent and child. Instead
of copying all memory pages immediately, the parent and child initially
share all pages marked as read-only. If either process writes to one of
these shared pages, a page fault triggers the kernel to create a private
copy for that process.
Note that modern CPUs include a <strong>Translation Lookaside Buffer (TLB)</strong>, a
hardware cache that stores recent virtual-to-physical address translations.
This leads to case where even after you modify the permission of the
address, the change is <strong>not immediately visible</strong> to the CPU if the TLB
still holds a cached, now-stale mapping. Therefore, you must maintain the
consistency with the TLB. To maintain memory protection correctness:</p>
<ul>
<li>The kernel must <strong>shut down</strong> TLB for all pages made read-only by
write-protection since they were previously writable.</li>
<li>The kernel must <strong>invalidate</strong> a TLB entry after a new private page is
installed , replacing a previously shared page.</li>
</ul>
<p>Without these TLB flushes, processes may continue using stale or incorrect
mappings, bypassing copy-on-write or causing data corruption.
In KeOS, copy-on-write works as follow:</p>
<ol>
<li>When a process invokes a <strong>fork</strong> system call, the kernel makes copy of
<a href="../../keos_project1/file_struct/struct.FileStruct.html" title="struct keos_project1::file_struct::FileStruct"><code>FileStruct</code></a>.</li>
<li>The kernel write-protected ptes by calling
<a href="../lazy_pager/struct.LazyPager.html#method.write_protect_ptes" title="associated function keos_project3::lazy_pager::LazyPager::write_protect_ptes"><code>LazyPager::write_protect_ptes</code></a> to make copy of <a href="../../keos_project2/mm_struct/struct.MmStruct.html" title="struct keos_project2::mm_struct::MmStruct"><code>MmStruct</code></a>. This
marks all writable pages as read-only when the child is created. This
ensures any future writes will trigger a page fault.</li>
<li>After write-protecting pages, the kernel <strong>shuts down the TLB</strong> entries
for those pages to remove stale writable translations from the CPU’s
cache. This is done via <a href="../../keos/mm/page_table/fn.tlb_shutdown.html" title="fn keos::mm::page_table::tlb_shutdown"><code>tlb_shutdown</code></a>.</li>
<li>Execute a new process for child with the copy of states.</li>
<li>Resume the execution of both parent and child.</li>
</ol>
<p>After resuming the execution, process might confront a <strong>page fault</strong> from
the write-protect. The page fault handler determines whether the fault is
copy-on-write fault with <a href="../lazy_pager/struct.PageFaultReason.html#method.is_cow_fault" title="method keos_project3::lazy_pager::PageFaultReason::is_cow_fault"><code>PageFaultReason::is_cow_fault</code></a> and handle it
with <a href="../lazy_pager/struct.LazyPager.html#method.do_copy_on_write" title="method keos_project3::lazy_pager::LazyPager::do_copy_on_write"><code>LazyPager::do_copy_on_write</code></a>. This function finds the pte with
<a href="../../keos_project2/page_table/struct.PageTable.html#method.walk_mut" title="method keos_project2::page_table::PageTable::walk_mut"><code>PageTable::walk_mut</code></a>, allocates and installs a new private copy of a
page. After mapping the new page, the kernel <strong>invalidates the old TLB
entry</strong> with the <a href="../../keos/mm/page_table/struct.StaleTLBEntry.html#method.invalidate" title="method keos::mm::page_table::StaleTLBEntry::invalidate"><code>StaleTLBEntry::invalidate</code></a>.</p>
<h3 id="implementation-requirements"><a class="doc-anchor" href="#implementation-requirements">§</a>Implementation Requirements</h3>
<p>You need to implement the followings:</p>
<ul>
<li><a href="../lazy_pager/struct.LazyPager.html#method.write_protect_ptes" title="associated function keos_project3::lazy_pager::LazyPager::write_protect_ptes"><code>LazyPager::write_protect_ptes</code></a></li>
<li><a href="../lazy_pager/struct.PageFaultReason.html#method.is_cow_fault" title="method keos_project3::lazy_pager::PageFaultReason::is_cow_fault"><code>PageFaultReason::is_cow_fault</code></a></li>
<li><a href="../lazy_pager/struct.LazyPager.html#method.do_copy_on_write" title="method keos_project3::lazy_pager::LazyPager::do_copy_on_write"><code>LazyPager::do_copy_on_write</code></a></li>
<li><a href="fn.fork.html" title="fn keos_project3::fork::fork"><code>fork</code></a></li>
</ul>
<p>This ends the project 3.</p>
</div></details><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.fork.html" title="fn keos_project3::fork::fork">fork</a></dt><dd>Creates a new process by duplicating the current process using
copy-on-write.</dd></dl></section></div></main></body></html>