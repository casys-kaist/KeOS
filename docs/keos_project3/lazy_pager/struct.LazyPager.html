<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The `LazyPager` structure implements lazy paging, where memory pages are mapped only when accessed (on page fault), instead of during `mmap` calls."><title>LazyPager in keos_project3::lazy_pager - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="keos_project3" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">LazyPager</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../keos_project3/index.html">keos_<wbr>project3</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Lazy<wbr>Pager</a></h2><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.do_copy_on_write" title="do_copy_on_write">do_copy_on_write</a></li><li><a href="#method.do_lazy_load" title="do_lazy_load">do_lazy_load</a></li><li><a href="#method.handle_page_fault" title="handle_page_fault">handle_page_fault</a></li><li><a href="#method.write_protect_ptes" title="write_protect_ptes">write_protect_ptes</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-LazyPager" title="Clone">Clone</a></li><li><a href="#impl-Pager-for-LazyPager" title="Pager">Pager</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-LazyPager" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-LazyPager" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-LazyPager" title="Send">Send</a></li><li><a href="#impl-Sync-for-LazyPager" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-LazyPager" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-LazyPager" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In keos_<wbr>project3::<wbr>lazy_<wbr>pager</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">keos_project3</a>::<wbr><a href="index.html">lazy_pager</a></div><h1>Struct <span class="struct">Lazy<wbr>Pager</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/keos_project3/lazy_pager.rs.html#185-187">Source</a> </span></div><pre class="rust item-decl"><code>pub struct LazyPager {}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The <a href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager"><code>LazyPager</code></a> structure implements lazy paging, where memory pages are
mapped only when accessed (on page fault), instead of during <code>mmap</code> calls.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-LazyPager" class="impl"><a class="src rightside" href="../../src/keos_project3/fork.rs.html#74-135">Source</a><a href="#impl-LazyPager" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.do_copy_on_write" class="method"><a class="src rightside" href="../../src/keos_project3/fork.rs.html#97-103">Source</a><h4 class="code-header">pub fn <a href="#method.do_copy_on_write" class="fn">do_copy_on_write</a>(
    &amp;mut self,
    page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    reason: &amp;<a class="struct" href="struct.PageFaultReason.html" title="struct keos_project3::lazy_pager::PageFaultReason">PageFaultReason</a>,
) -&gt; Result&lt;(), <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Handles a copy-on-write (COW) page fault by creating a private copy of
the faulted page.</p>
<p>This method is invoked when a process attempts to write to a page that
is currently shared and marked read-only as part of a copy-on-write
mapping. It ensures that the faulting process receives its own
writable copy of the page while preserving the original contents for
other processes that may still share the original page.</p>
<h6 id="steps"><a class="doc-anchor" href="#steps">§</a>Steps:</h6>
<ol>
<li>Find write-protected page table entry with <a href="../../keos_project2/page_table/struct.PageTable.html#method.walk_mut" title="method keos_project2::page_table::PageTable::walk_mut"><code>PageTable::walk_mut</code></a>.</li>
<li>Allocates a new page and copies the contents of the original page
into it.</li>
<li>Updates the page table to point to the new page with write
permissions.</li>
<li>Invalidates the TLB entry for the faulting address to ensure the CPU
reloads the mapping.</li>
</ol>
<h6 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h6>
<ul>
<li><code>page_table</code>: The faulting process’s page table.</li>
<li><code>reason</code>: Information about the page fault, including the faulting
address and access type.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_protect_ptes" class="method"><a class="src rightside" href="../../src/keos_project3/fork.rs.html#128-134">Source</a><h4 class="code-header">pub fn <a href="#method.write_protect_ptes" class="fn">write_protect_ptes</a>(
    mm_struct: &amp;mut <a class="struct" href="../../keos_project2/mm_struct/struct.MmStruct.html" title="struct keos_project2::mm_struct::MmStruct">MmStruct</a>&lt;<a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a>&gt;,
) -&gt; Result&lt;<a class="struct" href="../../keos_project2/mm_struct/struct.MmStruct.html" title="struct keos_project2::mm_struct::MmStruct">MmStruct</a>&lt;<a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a>&gt;, <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Applies write-protection to all user-accessible pages in the memory
layout.</p>
<p>This method is called during <code>fork</code> to prepare the address space for
copy-on-write semantics. It traverses the entire virtual memory
layout, identifies writable mappings, and rewrites their page table
entries (PTEs) as read-only. This allows parent and child
processes to safely share physical memory until one performs a write, at
which point a private copy is created.</p>
<p>After modifying the page tables, stale entries in the <strong>Translation
Lookaside Buffer (TLB)</strong> are invalidated to ensure that the CPU
observes the new permissions by calling <a href="../../keos/mm/page_table/fn.tlb_shutdown.html" title="fn keos::mm::page_table::tlb_shutdown"><code>tlb_shutdown</code></a>.</p>
<h6 id="parameters-1"><a class="doc-anchor" href="#parameters-1">§</a>Parameters</h6>
<ul>
<li><code>mm_struct</code>: The current process’s memory layout, including its
<a href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager"><code>LazyPager</code></a> state.</li>
</ul>
<h6 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h6>
<ul>
<li>A new <a href="../../keos_project2/mm_struct/struct.MmStruct.html" title="struct keos_project2::mm_struct::MmStruct"><code>MmStruct</code></a> representing the forked child process, with updated
page table mappings.</li>
</ul>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-LazyPager-1" class="impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#322-385">Source</a><a href="#impl-LazyPager-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.do_lazy_load" class="method"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#347-353">Source</a><h4 class="code-header">pub fn <a href="#method.do_lazy_load" class="fn">do_lazy_load</a>(
    &amp;mut self,
    page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    reason: &amp;<a class="struct" href="struct.PageFaultReason.html" title="struct keos_project3::lazy_pager::PageFaultReason">PageFaultReason</a>,
) -&gt; Result&lt;(), <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Handles a page fault by performing <strong>lazy loading</strong> of the faulting
page.</p>
<p>This method is invoked when a page fault occurs due to <strong>demand
paging</strong>— that is, when a program accesses a virtual address that is
validly mapped but not yet backed by a physical page. This function
allocates and installs the corresponding page into the page table on
demand.</p>
<p>The kernel may initialize the page from a file (if the mapping was
file-backed) or zero-fill it (if anonymous). The newly loaded page
must also be mapped with the correct permissions, as defined at the
time of the original <code>mmap</code>.</p>
<h5 id="parameters-2"><a class="doc-anchor" href="#parameters-2">§</a>Parameters</h5>
<ul>
<li><code>page_table</code>: The page table of the faulting process.</li>
<li><code>reason</code>: The <a href="struct.PageFaultReason.html" title="struct keos_project3::lazy_pager::PageFaultReason"><code>PageFaultReason</code></a> that describes the faulting reason.</li>
</ul>
<p>This must indicate a <strong>demand paging fault</strong>.</p>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<ul>
<li><code>Ok(())</code> if the page was successfully loaded and mapped.</li>
<li><code>Err(KernelError)</code>: If the faulting address is invalid, out of bounds,
or if page allocation fails.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.handle_page_fault" class="method"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#372-384">Source</a><h4 class="code-header">pub fn <a href="#method.handle_page_fault" class="fn">handle_page_fault</a>(
    &amp;mut self,
    page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    reason: &amp;<a class="struct" href="struct.PageFaultReason.html" title="struct keos_project3::lazy_pager::PageFaultReason">PageFaultReason</a>,
) -&gt; Result&lt;(), <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Handles a <strong>page fault</strong> by allocating a physical page and updating the
page table.</p>
<p>This function is called when a process accesses a lazily mapped page
that has not been allocated yet. The function must:</p>
<ol>
<li>Identify the faulting virtual address from <a href="struct.PageFaultReason.html" title="struct keos_project3::lazy_pager::PageFaultReason"><code>PageFaultReason</code></a>.</li>
<li>Check if the address was previously recorded in <code>mmap</code> metadata.</li>
<li>Allocate a new physical page.</li>
<li>Update the page table with the new mapping.</li>
<li>Invalidate the TLB entry to ensure memory consistency.</li>
</ol>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li><code>page_table</code>: Mutable reference to the page table.</li>
<li><code>reason</code>: The cause of the page fault, including the faulting address.</li>
</ul>
<p>If the faulting address was not mapped via <code>mmap</code>, the system should
trigger a <strong>segmentation fault</strong>, resulting process exit.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-LazyPager" class="impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#184">Source</a><a href="#impl-Clone-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl Clone for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#184">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Pager-for-LazyPager" class="impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#189-258">Source</a><a href="#impl-Pager-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../keos_project2/pager/trait.Pager.html" title="trait keos_project2::pager::Pager">Pager</a> for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#193-197">Source</a><a href="#method.new" class="anchor">§</a><h4 class="code-header">fn <a href="../../keos_project2/pager/trait.Pager.html#tymethod.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new instance of <a href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager"><code>LazyPager</code></a>.</p>
<p>This constructor initializes an empty <a href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager"><code>LazyPager</code></a> struct.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.mmap" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#205-215">Source</a><a href="#method.mmap" class="anchor">§</a><h4 class="code-header">fn <a href="../../keos_project2/pager/trait.Pager.html#tymethod.mmap" class="fn">mmap</a>(
    &amp;mut self,
    _page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    addr: Va,
    size: usize,
    prot: <a class="struct" href="../../keos/mm/page_table/struct.Permission.html" title="struct keos::mm::page_table::Permission">Permission</a>,
    file: Option&lt;&amp;<a class="struct" href="../../keos/fs/struct.RegularFile.html" title="struct keos::fs::RegularFile">RegularFile</a>&gt;,
    offset: usize,
) -&gt; Result&lt;usize, <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Memory map function (<code>mmap</code>) for lazy paging.</p>
<p>This function creates the metadata for memory mappings, and delegate the
real mappings on page fault.</p>
<p>Returns an address for the mapped area.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.munmap" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#224-226">Source</a><a href="#method.munmap" class="anchor">§</a><h4 class="code-header">fn <a href="../../keos_project2/pager/trait.Pager.html#tymethod.munmap" class="fn">munmap</a>(
    &amp;mut self,
    page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    addr: Va,
) -&gt; Result&lt;usize, <a class="enum" href="../../keos/enum.KernelError.html" title="enum keos::KernelError">KernelError</a>&gt;</h4></section></summary><div class="docblock"><p>Memory unmap function (<code>munmap</code>) for lazy paging.</p>
<p>This function would unmap a previously mapped memory region, releasing
any associated resources.</p>
<h5 id="returns-2"><a class="doc-anchor" href="#returns-2">§</a>Returns</h5>
<ul>
<li>Zero (if succeed) or an error (<a href="../../keos/enum.KernelError.html" title="enum keos::KernelError"><code>KernelError</code></a>).</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_user_page" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#241-247">Source</a><a href="#method.get_user_page" class="anchor">§</a><h4 class="code-header">fn <a href="../../keos_project2/pager/trait.Pager.html#tymethod.get_user_page" class="fn">get_user_page</a>(
    &amp;mut self,
    page_table: &amp;mut <a class="struct" href="../../keos_project2/page_table/struct.PageTable.html" title="struct keos_project2::page_table::PageTable">PageTable</a>,
    addr: Va,
) -&gt; Option&lt;(<a class="struct" href="../../keos/mm/struct.PageRef.html" title="struct keos::mm::PageRef">PageRef</a>&lt;'_&gt;, <a class="struct" href="../../keos/mm/page_table/struct.Permission.html" title="struct keos::mm::page_table::Permission">Permission</a>)&gt;</h4></section></summary><div class="docblock"><p>Find a mapped page at the given virtual address. If the page for addr is
not loaded, load it and then returns.</p>
<p>This function searches for a memory page mapped at <code>addr</code> and, if found,
returns a tuple of <a href="../../keos/mm/struct.PageRef.html" title="struct keos::mm::PageRef"><code>PageRef</code></a> to the page and its corresponding
<a href="../../keos/mm/page_table/struct.Permission.html" title="struct keos::mm::page_table::Permission"><code>Permission</code></a> flags.</p>
<h5 id="parameters-3"><a class="doc-anchor" href="#parameters-3">§</a>Parameters</h5>
<ul>
<li><code>addr</code>: The virtual address ([<code>Va</code>]) of the page to find.</li>
</ul>
<h5 id="returns-3"><a class="doc-anchor" href="#returns-3">§</a>Returns</h5>
<ul>
<li><code>Some(([</code>PageRef<code>], [</code>Permission<code>]))</code>: If the page is found.</li>
<li><code>None</code>: If no mapped page is found at <code>addr</code>.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.access_ok" class="method trait-impl"><a class="src rightside" href="../../src/keos_project3/lazy_pager.rs.html#255-257">Source</a><a href="#method.access_ok" class="anchor">§</a><h4 class="code-header">fn <a href="../../keos_project2/pager/trait.Pager.html#tymethod.access_ok" class="fn">access_ok</a>(&amp;self, va: Va, is_write: bool) -&gt; bool</h4></section></summary><div class="docblock"><p>Checks whether access to the given virtual address is permitted.</p>
<p>This function verifies that a virtual address <code>va</code> is part of a valid
memory mapping and that the requested access type (read or write) is
allowed by the page’s protection flags. Note that this does not trigger
the demand paging.</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-LazyPager" class="impl"><a href="#impl-Freeze-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl Freeze for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section><section id="impl-RefUnwindSafe-for-LazyPager" class="impl"><a href="#impl-RefUnwindSafe-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl RefUnwindSafe for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section><section id="impl-Send-for-LazyPager" class="impl"><a href="#impl-Send-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl Send for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section><section id="impl-Sync-for-LazyPager" class="impl"><a href="#impl-Sync-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl Sync for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section><section id="impl-Unpin-for-LazyPager" class="impl"><a href="#impl-Unpin-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl Unpin for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section><section id="impl-UnwindSafe-for-LazyPager" class="impl"><a href="#impl-UnwindSafe-for-LazyPager" class="anchor">§</a><h3 class="code-header">impl UnwindSafe for <a class="struct" href="struct.LazyPager.html" title="struct keos_project3::lazy_pager::LazyPager">LazyPager</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; CloneToUninit for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">clone_to_uninit</a>(&amp;self, dest: *mut u8)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ToOwned for T<div class="where">where
    T: Clone,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_into</a>(&amp;self, target: &amp;mut T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>