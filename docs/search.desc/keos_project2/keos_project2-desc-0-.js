searchState.loadedDescShard("keos_project2", 0, "Project 2: Memory Management\nCloses an open file descriptor.\nTerminates the calling process.\nMap the memory.\nUnmap the memory.\nOpens a file and returns a file descriptor.\nCreate an interprocess communication channel.\nReads data from a file descriptor.\nMoves the file offset of an open file.\nRepresents system call numbers used in project2\nRetrieves the current file offset.\nWrites data to a file descriptor.\nPager with Eager Paging Policy\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nELF Loading.\nMemory State of a process\nFour-Level Page Table of x86_64\nPager, a trait for paging policy\nThe process model for project2\n<code>EagerPager</code> is a struct that implements the <code>Pager</code> trait. It …\nRepresent a mapping of contiguous memory.\nChecks whether access to the given virtual address is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a mapped page at the given virtual address.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSize of the area.\nMemory map function (<code>mmap</code>) for eager paging.\nMemory unmap function (<code>munmap</code>) for eager paging.\nCreates a new instance of <code>EagerPager</code>.\nPermission of the area.\nA context that holds the necessary state for loading and …\nBuilds a user stack and initializes it with arguments.\nUtility to parsing ELF file.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new memory state and initializes a user process …\nLoads program headers (<code>Phdr</code>s) from an ELF binary into …\nVirtual memory layout for the new user program.\nInitial CPU register values for the user process, …\n<code>StackBuilder</code>, a utility for constructing a user-space …\nDynamic linking information.\nRepresents the ELF file header.\nSegment is executable.\nRepresents an ELF file in memory.\nGNU-specific: Exception handling information.\nGNU-specific.\nGNU-specific: Read-only after relocation.\nGNU-specific: Stack segment flags.\nInterpreter path (for dynamically linked executables).\nLoadable segment.\nAuxiliary information.\nUnused segment.\nSegment permission flags for ELF program headers.\nELF program header type.\nELF program header for 64-bit binaries.\nProgram header table itself.\nIterator over program headers in an ELF binary.\nSegment is readable.\nReserved.\nThread-Local Storage (TLS) template.\nSegment is writable.\nIdentifies the target operating system ABI.\nFurther specifies the ABI version.\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nIndicates 32-bit or 64-bit format.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nSpecifies little-endian or big-endian encoding.\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nSize of this header in bytes.\nMemory address of the entry point where execution starts.\nProcessor-specific flags.\nTarget instruction set architecture.\nSize of a program header table entry in bytes.\nNumber of entries in the program header table.\nOffset of the program header table in bytes.\nSize of a section header table entry in bytes.\nNumber of entries in the section header table.\nOffset of the section header table in bytes.\nIndex of the section header table entry that contains …\nObject file type (e.g., executable, shared object, …\nELF version (should be <code>1</code>).\nReturns an empty set of flags.\nReference to the backing file containing ELF data.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nAttempts to create an <code>Elf</code> object from a <code>RegularFile</code>.\nA parsed ELF header\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nThe ELF magic number (<code>0x7F</code> followed by <code>ELF</code> in ASCII).\nReturns the complement of this set of flags.\nAlignment of the segment (must be a power of two).\nSize of the segment in the file.\nSegment permissions.\nSize of the segment in memory.\nOffset in the file where the segment starts.\nPhysical address (not commonly used in modern OSes).\nVirtual address where the segment should be mapped in …\nUnused padding bytes (must be zero).\nGet a ELF segment permissions (<code>PFlags</code>) of this Phdr in …\nReturns an iterator over the program headers.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nSegment type.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nELF version (set to <code>1</code> for the original and current …\nA utility for constructing a user-space stack layout.\nAligns the stack pointer to the given alignment.\nConsume the <code>StackBuilder</code> and return the stack pointer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>StackBuilder</code> instance for building a …\nPushes a byte array onto the stack.\nPushes a string onto the stack as a C-style string …\nPushes a <code>usize</code> value onto the stack.\nReturns the current stack pointer.\nThe <code>MmStruct</code> represents the memory state for a specific …\nThis function ensures that system calls using memory …\nWrapper function for the pager’s <code>mmap</code> method. It …\nReturns the argument unchanged.\nFind a mapped page at the given virtual address and apply …\nCalls <code>U::from(self)</code>.\nMaps a file into the process’s virtual address space.\nUnmaps a memory-mapped file region.\nCreates a new <code>MmStruct</code> with an empty page table and a new …\nThe page table that maintains mappings between virtual and …\nThe pager that handles memory allocation (<code>mmap</code>) and …\nPage Table Structure for x86_64 Architecture.\nRepresents page table indices for a given virtual address …\nA mutable reference to a page table entry (PTE) associated …\nClears all entries from the page table and deallocates …\nClears the current mapping by returning the physical page …\nMap a physical address (<code>pa</code>) to a virtual address (<code>va</code>) with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExtracts page table indices from a given virtual address (…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap a virtual address (<code>va</code>) to a physical page (<code>pg</code>) with the\nCreate an empty page table.\nGet physical address of this page table.\nPage Directory Index (PDEI).\nPage Directory Pointer table Index (PDPTEI).\nPage Map Level 4 Index (PML4EI).\nPage Table Index (PTEI).\nSets this page table entry to map to the given page with …\nUnmap the given virtual address (<code>va</code>) and return the …\nThe virtual address (VA) associated with this page table …\nWalk through the page table to find reference to the …\nWalk through the page table to find mutable reference for …\nThe <code>Pager</code> trait defines the interface for memory paging …\nChecks whether access to the given virtual address is …\nResolves a virtual address to a page reference.\nMaps a virtual memory region into the process’s address …\nUnmaps a previously mapped memory region.\nCreates a new instance of the pager.\nA process state of project 2, which contains file struct …\nValidates whether the given memory range is accessible for …\nExit a process.\nReturns the argument unchanged.\nCreate a process with given <code>MmStruct</code>.\nCalls <code>U::from(self)</code>.\nHandles a system call request from a user program.")