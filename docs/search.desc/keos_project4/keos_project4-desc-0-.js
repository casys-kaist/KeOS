searchState.loadedDescShard("keos_project4", 0, "Project 4: Synchronization and Multithreading\nCloses an open file descriptor.\nTerminates the calling thread.\nTerminates the process, by terminating all threads.\nFork the process.\nGet Physical Address of Page (for grading purposes only)\nMap the memory.\nUnmap the memory.\nOpens a file and returns a file descriptor.\nCreate an interprocess communication channel.\nReads data from a file descriptor.\nMoves the file offset of an open file.\nRepresents system call numbers used in project4.\nRetrieves the current file offset.\nCreate a thread.\nJoin a Thread.\nWrites data to a file descriptor.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMultithreaded Process\nMulticore Round-Robin Scheduling.\nSynchronization Primitives.\nA thread state of project 4, which contains file and …\nValidates whether the given memory range is accessible for …\nExit the current thread.\nExit a process.\nReturns the argument unchanged.\nCreate a thread with given <code>MmStruct</code> and <code>FileStruct</code>.\nCreate a thread with given <code>MmStruct</code>.\nCalls <code>U::from(self)</code>.\nHandles a page fault.\nHandles a system call request from a user program.\nCreate a new thread in the current process.\nWait for a thread to finish.\nExecutes a closure with mutable access to the underlying …\nExecutes a closure with mutable access to the underlying …\nExecutes a closure with mutable access to the underlying …\nRuns a given closure with physical address of page table.\nPer-core scheduler state.\nA round robin scheduler.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>RoundRobin</code> scheduler.\nRemaining time slice for the currently running thread.\nQueue of threads ready to run on this CPU core.\nCondition Variable.\nMutex.\nSemaphore.\nA Condition Variable\nWakes up all blocked threads on this condvar.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new condition variable which is ready to be …\nWakes up one blocked thread on this condvar.\nBlocks the current thread while <code>predicate</code> returns <code>true</code>.\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nCreates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this mutex, returning the underlying data.\nAcquires a mutex, blocking the current thread until it is …\nCreates a new mutex in an unlocked state ready for use.\nAttempts to acquire this lock.\nReleases the underlying <code>Mutex</code>.\nCounting semaphore.\nAn RAII implementation of a “scoped semaphore”. When …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new semaphore initialized with a specified …\nReleases a permit back to the semaphore.\nWaits until a permit becomes available and then acquires …")