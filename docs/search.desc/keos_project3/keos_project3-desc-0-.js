searchState.loadedDescShard("keos_project3", 0, "Project 3: Advanced Memory Management\nCloses an open file descriptor.\nTerminates the calling process.\nFork the process.\nGet Physical Address of Page (for grading purposes only)\nMap the memory.\nUnmap the memory.\nOpens a file and returns a file descriptor.\nCreate an interprocess communication channel.\nReads data from a file descriptor.\nMoves the file offset of an open file.\nRepresents system call numbers used in project3.\nRetrieves the current file offset.\nWrites data to a file descriptor.\n<code>Fork</code> with Copy-On-Write optimization.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLazy Paging\nThe process model for project3.\nCreates a new process by duplicating the current process …\nA loader for anonymous memory regions.\nA loader for file-backed memory regions.\nThe <code>LazyPager</code> structure implements lazy paging, where …\nA trait for loading the contents of a virtual memory page …\nRepresents the reason for a page fault in a virtual memory …\nRepresents a memory-mapped region within a process’s …\nChecks whether access to the given virtual address is …\nHandles a copy-on-write (COW) page fault by creating a …\nHandles a page fault by performing <strong>lazy loading</strong> of the …\nThe address that caused the page fault.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a mapped page at the given virtual address. If the …\nHandles a <strong>page fault</strong> by allocating a physical page and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the fault is a <strong>copy-on-write</strong> violation.\nReturns <code>true</code> if the fault is due to <strong>demand paging</strong>.\nIndicates whether the page that caused the fault is …\nIndicates whether the fault was due to a write access …\nLoads and returns the content for the page at the given …\nReturns a zero-filled page for the given virtual address.\nLoads a page from the file based on the given virtual …\nA handle to the memory loader for this region.\nMemory map function (<code>mmap</code>) for lazy paging.\nMemory unmap function (<code>munmap</code>) for lazy paging.\nCreates a new instance of <code>LazyPager</code>.\nProbe the cause of page fault into a <code>PageFaultReason</code>.\nApplies write-protection to all user-accessible pages in …\nA process state of project 3, which contains file struct …\nValidates whether the given memory range is accessible for …\nExit a process.\nReturns the argument unchanged.\nCreate a process with given <code>MmStruct</code>.\nCalls <code>U::from(self)</code>.\nHandles a page fault by acquiring the memory state lock …\nHandles a system call request from a user program.")