<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="MMIO based simple printer device."><title>kev_project2::mmio - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="kev_project2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module mmio</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../kev_project2/index.html">kev_<wbr>project2</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module mmio</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#background" title="Background">Background</a></li><li><a href="#tasks" title="Tasks">Tasks</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate kev_<wbr>project2</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">kev_project2</a></div><h1>Module <span>mmio</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/kev_project2/mmio.rs.html#1-107">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>MMIO based simple printer device.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3>
<p>Memory-mapped I/O uses the same address space for both main memory and I/O
devices. Unlike PIO, which uses dedicated instructions, in MMIO, one can
think of the memory and register of I/O devices as if they are mapped in a
specific address of main memory. This method allows for the convenient and
fast definition of I/O device behavior and concise implementation of the CPU
and I/O devices.</p>
<p>In memory-mapped I/O, the same memory address space is used for accessing
both main memory (RAM) and I/O devices. Commands for accessing main memory
(such as load and store) are also used to access devices, reading from and
writing to memory instead. For instance, if there exists memory-mapped I/O
(MMIO) mapping between a console device and CPU at address 0x00ff, writing
‘a’ to the 0x00ff will print a letter ‘a’ to the console device.</p>
<p>The specific area of memory for these operations can be temporarily agreed
upon between a CPU and device or it can be a permanently assigned area.
As an example, modern PCIe devices negotiate the locations of the MMIO
sections with a CPU by using a base address register (BAR) in the
initialization process.</p>
<p>On modern CPUs, MMIO is performed by the memory management unit (MMU), which
is a hardware component responsible for managing memory access.
When a program running on the CPU performs an I/O operation on a
memory-mapped location, the MMU intercepts the memory access and sends it to
the appropriate hardware device, which performs the requested operation.
Each I/O device monitors the CPU’s address bus and when the memory is
accessed, the device executes the command and writes the result to a
specific memory location or performs the command.</p>
<p>Memory-mapped I/O is generally faster than Programmed I/O (PIO) because it
avoids the overhead of the processor having to manage the I/O operations
directly. In PIO, the CPU should execute IN and OUT operations to
communicate with peripheral devices. Which causes delays and limits overall
system performance. In contrast, MMIO allows I/O devices to be directly
mapped to memory and managed by MMU. This makes I/O operations can be
performed quickly and efficiently, without requiring the CPU to spend a lot
of time managing the I/O operations directly.</p>
<h3 id="tasks"><a class="doc-anchor" href="#tasks">§</a>Tasks</h3>
<p>In this project, you are requested to implement simple virtual MMIO control
for the purpose of the printing text on the host console. In our MMIO
PrinterDev specifications, we dictate the usage of 0xcafe0000 guest physical
address for the buffer, which contains an array of utf8 strings. The length
of the array can be founded at the 0xcafe0008, while the doorbell is located
at 0xcafe0010. The doorbell in MMIO typically refers to a deginated memory
location used to trigger device operations. The PrinterDev virtual device
lauches an operation when a write occurs to the doorbell address, and
subsequently fetches the address and length of the string buffer.
It then parses the string data from the buffer and outputs given text to the
host console. In summary:</p>
<ul>
<li>0xcafe0000: Guest physical address for the utf8 string buffer</li>
<li>0xcafe0008: Length of the utf8 string buffer</li>
<li>0xcafe0010: The doorbell which notifies VMM to print the registered string
to the console</li>
</ul>
<p>Your device SHOULD parses the string data from the buffer and outputs the
given text to the teletype device. You can translate a raw pointer to slice
by using <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>core::slice::from_raw_parts</code></a>.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.PrinterDev.html" title="struct kev_project2::mmio::PrinterDev">Printer<wbr>Dev</a></dt></dl></section></div></main></body></html>