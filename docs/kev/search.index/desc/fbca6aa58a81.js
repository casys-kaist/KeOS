rd_("mCode Segment.mData Segment.nExtra Segment.AjExtra Segment (E -&gt; F).AjExtra Segment (F -&gt; G).AfVCpu can be continued.nStack Segment.AdThe virtual machine.AhGet smp id of this vcpu.BmGet a physical address pointed by this entry.000lR8 register.lR9 register.AjVirtual machine interface.AiWeak reference of the vm.AhVm that owned this VCpu.oVm to run keos.mCr0 Register.AjControlRegister2 Register.CdControlRegister3 Register. Contains Page-Table root.mCr4 Register.BaRepresents an ELF file in memory.AfGuest physical addressAeGuest virtual addressAfThe unique kernel IDT.CiIf this control is 1, the monitor trap flag debugging \xe2\x80\xa6AhModel specific register.C`Trait that represent handlers for MSR registers.AgNon-maskable interrupt.AaA Port-mapped io.AgHas repe or rep prefix.BdThread-Local Storage (TLS) template.AcTask State Segment.B`Task-state-struct segment (TSS).BkIdentifies the target operating system ABI.BaAcknowledge the consumed request.BeReturns the set containing all flags.0000000000000BaBuffer to print. Provides on rdi.AoCollection of Emulated devices.0AlUtility to parsing ELF file.AdExtended Page Table.AkWelcome to the KeV project.DkMap <code>pg</code> into <code>va</code> with permission <code>perm</code>.AnModel-specific register (MSR).CcMSR handlers to test msr instructions correctly \xe2\x80\xa6BjModel-specific register vmexit controller.BhGet a builder object to create a new vm.BjCreate a new virtual address with a check.BkCreate a new physical address with a check.AiCreate a new Vmcs struct.BeCreate a new instance of NoEptVmStateAfCreate a new StackMsr.AmCreate a new PioHandlerQueue.BbCreate a new hypercall controller.AlCreate a new msr controller.AlCreate a new pio controller.AnCreate a new cpuid controller.AhCreate a new MmioRegion.BdCreate a new mmio vmexit controller.AgCreate a new virtqueue.AkInterrupt 2 - NMI InterruptBlReturns the complement of this set of flags.0000000000000BdUnused padding bytes (must be zero).AhPort mapped io interfaceCcPio handlers to test pio instructions correctly \xe2\x80\xa6BaPort-mapped IO vmexit controller.mR10 register.mR11 register.mR12 register.mR13 register.mR14 register.mR15 register.mRAX register.mRBP register.mRBX register.mRCX register.mRDI register.mRDX register.mRSI register.CkInserts or removes the specified flags depending on the \xe2\x80\xa60000000000000CdReturns the set difference of the two sets of flags.0000000000000AbTask-state segmentCjSet if the access causing the EPT violation was a data \xe2\x80\xa60CfSet if the access causing the EPT violation was an \xe2\x80\xa6ChThe logical-AND of bit 0 in the EPT paging-structure \xe2\x80\xa6ChThe logical-AND of bit 1 in the EPT paging-structure \xe2\x80\xa6ChThe logical-AND of bit 2 in the EPT paging-structure \xe2\x80\xa6ChIf the \xe2\x80\x9cmode-based execute control\xe2\x80\x9d VM-execution \xe2\x80\xa6CmSet if the guest linear-address field is valid. The guest \xe2\x80\xa6ChIf bit 7 is 1: \xe2\x80\xa2 Set if the access causing the EPT \xe2\x80\xa6CiIf bit 7 is 1, bit 8 is 1, and the processor supports \xe2\x80\xa6BkHypercalls that this controller can handle.BeInput byte from I/O port into memory.BlInput double word from I/O port into memory.BeInput word from I/O port into memory.AaLoadable segment.AcHas none of prefix.AfAuxiliary information.mNull segment.oUnused segment.AfOutput a byte (1 byte)AnOutput a double word (4 bytes)AgOutput a word (2 bytes)BgELF program header for 64-bit binaries.AlProgram header table itself.Cjindicates whether reads are allowed from the 512-GByte \xe2\x80\xa6Chindicates whether reads are allowed from the 1-GByte \xe2\x80\xa6Chindicates whether reads are allowed from the 2-MByte \xe2\x80\xa6Cmindicates whether reads are allowed from the 4-KByte page \xe2\x80\xa6AaPage is readable.AdSegment is readable.dReadCkWhen set, the page fault was caused while CPL = 3. This \xe2\x80\xa6lVirtual cpu.AnVirtual Machine Control State.CdReturns the raw value of the flags currently stored.0000000000000AkExit code. Provides on rdi.BoSpecifies little-endian or big-endian encoding.AhDump the activated vmcs.mExit this vm.CbReference to the backing file containing ELF data.AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000Begeneral purpose register of the vcpu.BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000lJoin the vm.CaKick the doorbell to request commands to the VMM.BaMMIO based simple printer device.BcMemory-mapped IO vmexit controller.AjPort of the io iostructionBoRead from the vmcs field of the activated vmcs.BiSize of buffer to print. Provides on rsi.AkVirtual CPU implementation.nGet vcpu #idx.CbVirtual-Machine Control State (VMCS) related apis.AcThe activated vmcs.CiWalk the extended page table and return corresponding \xe2\x80\xa6CiIf bit 7 is 1, bit 8 is 1, and the processor supports \xe2\x80\xa60C`NMI unblocking due to IRET (see Section 28.2.3).CeSet if the access causing the EPT violation was a \xe2\x80\xa6CmIf supervisor shadow-stack control is enabled (by setting \xe2\x80\xa6ChThis bit is set if the EPT violation was caused as a \xe2\x80\xa6CeThis bit is set if the access was asynchronous to \xe2\x80\xa6Cnindicates whether software has written to the 4-KByte page \xe2\x80\xa6BcInterrupt 1 - Debug Exception (#DB)AnError Kind for setup_bsp_vcpu.AeError for setup_vbsp.0kVmcs field.BaInput byte from I/O port into AL.BaInput word from I/O port into AX.nA Magic value.AhELF program header type.BaPrint the message to the console.BdTraits to probe vcpu internal state.0A`Device is ready.AaReset the device.jHas repne.iReserved.AnVmState neutral Vm operations.Ciindicates whether writes are allowed to the 512-GByte \xe2\x80\xa6Cnindicates whether writes are allowed to the 1-GByte region \xe2\x80\xa6Cnindicates whether writes are allowed to the 2-MByte region \xe2\x80\xa6Clindicates whether writes are allowed to the 4-KByte page \xe2\x80\xa6AaPage is writable.AdSegment is writable.eWriteBjVMCS data (implementation-specific format)BkReturns the union of the two sets of flags.0000000000000BbIndicates 32-bit or 64-bit format.A`Clear this VMCS.AgGet cpuid of this core.AhCpuid vmexit controller.BcInterrupt 1 - Debug Exception (#DB)AnReturns an empty set of flags.0000000000000BeGet a entry point of the this kernel.AgGet a flags this entry.000DoThe ELF magic number (<code>0x7F</code> followed by <code>ELF</code> in ASCII).C`Lazy loader and pager for guest virtual machine.BmReturns an iterator over the program headers.AaHandler on wrmsr.AbThe state of VCpu.BbGlobal and Local Descriptor Table.mSegment type.EcReturns the union of between the flags in <code>self</code> and <code>other</code>.0000000000000EmUnmap the <code>gpa</code> and returns <code>Page</code> that was mapped to <code>gpa</code>.BnWrite to the vmcs field of the activated vmcs.6oVCpu is exited.AkExternal Interrupt is come.BiInput double word from I/O port into EAX.CfInterpreter path (for dynamically linked executables).oVCpu is kicked.CaSegment permission flags for ELF program headers.BbPossible prefix of io instruction.grflags.AjA Thread for KeV projects.BoVerify guest paging. If the \xe2\x80\x9cguest-paging \xe2\x80\xa6fX2ApicCgReturns the intersection between the two sets of flags.0000000000000ChReturns the left flags, but with all the right flags \xe2\x80\xa60000000000000DlMap <code>hpa</code> into <code>pa</code> with permission <code>perm</code>.CfObject file type (e.g., executable, shared object, \xe2\x80\xa6BeHandle the vmexit on this controller.BeHandle the hypercall <code>hc</code>.Cjhandle I/O instructions on the device indicated by the \xe2\x80\xa6AcA parsed ELF headerBeInserts the specified flags in-place.000000B`Insert msr handler to the index.1111111CiReturns <code>true</code> if all flags are currently set.0000000000000BeRemoves the specified flags in-place.0000000000000CkBits 30:0: VMCS revision identifier Bit 31: shadow-VMCS \xe2\x80\xa6BcSet physical address of this entry.000AdStatus of the deviceBeToggles the specified flags in-place.0000000000000AjSimple Virtio block deviceBbCollections of vmexit controllers.lX2apic msrs.A`x2APIC EmulationAlDynamic linking information.CcIf the \xe2\x80\x9cmode-based execute control for EPT\xe2\x80\x9d \xe2\x80\xa6000BnHalt the vcpu with exitcode <code>code</code>.BbNormal handler without error code.ClWhen set, the page fault was caused by a page-protection \xe2\x80\xa6AaTypes of segment.nUnknown error.gVCpuOpsAjPossible errorkind for Vm.CbError that occurs when vmwrite instruction failed.AePer-vm private state.AfThe Vmstate of VmBase.0CiMemory address of the entry point where execution starts.AiProcessor-specific flags.BnNumber of entries in the program header table.BlOffset of the program header table in bytes.BnNumber of entries in the section header table.BlOffset of the section header table in bytes.AiGet ept ptr of the pager.BfGet a fetcher object of the virtqueue.CiTranslate guest physical address to host physical address0ChTranslate guest physical address to host virtual address0ChTranslate guest virtual address to host physical address0CgTranslate guest virtual address to host virtual address0oVm to run keos.CbAlignment of the segment (must be a power of two).AdSegment permissions.AnSize of the segment in memory.CdPhysical address (not commonly used in modern OSes).CiVirtual address where the segment should be mapped in \xe2\x80\xa6B`Resolve the requested hypercall.Di<code>machine_restart()</code> is emergency restart function since it \xe2\x80\xa6hvcpu id.DcELF version (set to <code>1</code> for the original and current \xe2\x80\xa6AoInterface to play with vmexits.CkIf bit 6 of EPTP is 1, accessed flag for EPT; indicates \xe2\x80\xa600Clindicates whether software has accessed the 4-KByte page \xe2\x80\xa6mDevice is ok.BiGNU-specific: Read-only after relocation.BbGNU-specific: Stack segment flags.BjMSR entries that can be passed through \xe2\x80\xa6iNot existCeemulation of a msr that mimics the behavior of stack.CkThis control determines whether I/O bitmaps are used to \xe2\x80\xa6AgUser code segment (UC).AgUser data segment (UD).AlHandle for maintaining a VM.AkPossible errorkind for Vmx.BaMake this VMCS as a working VMCS.EeReturns <code>true</code> if all of the flags in <code>other</code> are contained \xe2\x80\xa60000000000000AmSize of this header in bytes.AfFinalize this builder.BhGet the VCpuOps from the id of the VCpu.BiVector of interrupt or exception: BIT 7~0CkReturns <code>true</code> if no flags are currently stored.0000000000000CeIndicate whether this vcpu is launched after vmclear.BbAttach a page at <code>gpa</code>.B`Size of the segment in the file.BlOffset in the file where the segment starts.BdPop a single entry to the virtqueue.Aaread current cr3.B`Insert pio handler to the index.BdAdd a mmio region to the controller.AoSet a permission of this entry.000AcSetup the ap state.BjDirection and the Value of the instructionAoRepresents the ELF file header.AdThe Vmbase with EPT.AeSupported hypercalls.CeTrait that represent the enumeration of supported \xe2\x80\xa6BfVM entry with invalid control field(s)ChThis control determines whether the IA32_PKRS MSR is \xe2\x80\xa60CnThis control determines whether executions of MOV DR cause \xe2\x80\xa6CmThis control determines whether executions of MWAIT cause \xe2\x80\xa6CmThis control determines whether executions of PAUSE cause \xe2\x80\xa6BiInterrupt 14 - Page-Fault Exception (#PF)CmThis control determines whether executions of RDPMC cause \xe2\x80\xa6CkThis control determines whether executions of RDTSC and \xe2\x80\xa6CkThis control determines whether MSR bitmaps are used to \xe2\x80\xa6ChThis control determines whether executions of RDTSC, \xe2\x80\xa6AaUnaligned addressAcVcpu related error.AgPer-vcpu private state.AfPer-Vcpu private stateAoThe Vcpu state of NoEptVmState.0BbA container for holding virtqueue.BkBuilder factory to build a virtual machine.AmGet currently activated vmcs.BiDirection and value of the io instructionBdTarget instruction set architecture.BgELF version (should be <code>1</code>).B`Get enabled exit control fields.CkConvert from underlying bit representation, unless that \xe2\x80\xa60000000000000DnAttempts to create an <code>Elf</code> object from a <code>RegularFile</code>.AiHypercalls for project 2.AlHypercall vmexit controller.AcVMX-abort indicatorjInterrupt.AkKernel GS (General Segment)nKick the vcpu.iMSR indexiMSR valueBbVirtual machine control structure.Di<code>machine_power_off()</code> is emergency shutdown function since \xe2\x80\xa6AfStart this vm\xe2\x80\x99s bsp.B`A representation of active vmcs.BhInterrupt 3 - Breakpoint Exception (#BP);AfMsr vmexit controller.AfPio vmexit controller.AhCpuid vmexit controller.AgMmio vmexit controller.AiHas a duplicated mapping.ChIf this control is 1, extended page tables (EPT) are \xe2\x80\xa6CgIf this control is 1, an access to a guest-physical \xe2\x80\xa6AcPage is executable.AfSegment is executable.AnEnumeration of vmexit reasons.BmGNU-specific: Exception handling information.CiThis determines whether executions of INVLPG cause VM \xe2\x80\xa6AmCurrent Cr0 value is invalid.AmCurrent Cr4 value is invalid.BjInterrupt 10 - Invalid TSS Exception (#TS)AiKernel code segment (KC).AiKernel data segment (KD).AkRepresentation of interval.mMust be zero.CnIf this control is 1, a VM exit occurs at the beginning of \xe2\x80\xa6AlPossible memory permissions.CfTrait that represent handlers for port-mapped devices.BjInterrupt 12 - Stack Fault Exception (#SS)AhInterrupt 15 - Reserved.AiInterrupt 21 - Reserved1.AiInterrupt 22 - Reserved2.AiInterrupt 23 - Reserved3.AiInterrupt 24 - Reserved4.AiInterrupt 25 - Reserved5.AiInterrupt 26 - Reserved6.AiInterrupt 27 - Reserved7.AiInterrupt 28 - Reserved8.AiInterrupt 29 - Reserved9.BhInterrupt 3 - Breakpoint Exception (#BP)BlReturns the complement of this set of flags.0000000000000EeReturns the difference between the flags in <code>self</code> and <code>other</code>.0000000000000CiIndex of the section header table entry that contains \xe2\x80\xa6BaGet enabled entry control fields.BlCreate a new vm pager from the kernel image.EeReturns <code>true</code> if there are flags common to both <code>self</code> and \xe2\x80\xa60000000000000A`Cast into usize.0DeIntrinsics of x86_64 not included in <code>core::arch::x86_64</code>.BiInterrupt 14 - Page-Fault Exception (#PF)DgGet a ELF segment permissions (<code>PFlags</code>) of this Phdr in \xe2\x80\xa6BePush a single entry to the virtqueue.jQueue HeadAeSize of the virtqueuejQueue tailCbSetup the virtual bootstrap processor (bsp) state.oStart the vcpu.BfDisables all flags enabled in the set.0000000000000AnCreate per-vcpu private state.AhVirtqueue implementationBdFlags and MSRs for VMX capabilities.ClIn conjunction with the CR3-target controls (see Section \xe2\x80\xa6CnThis control determines whether executions of MOV from CR3 \xe2\x80\xa6ClThis control determines whether executions of MOV to CR8 \xe2\x80\xa6BjInterrupt 0 - Divide Error Exception (#DE)BjInterrupt 8 - Double Fault Exception (#DF)CgIf this control is 1, cached translations of linear \xe2\x80\xa6CkTable 28-5. Format of an EPT Page-Directory Entry (PDE) \xe2\x80\xa6CmTable 29-6. Format of an EPT Page-Table Entry that Maps a \xe2\x80\xa6AcExternal interrupt.lExternal IntmGNU-specific.CnThis control determines whether executions of HLT cause VM \xe2\x80\xa6CnIf this control is 1, a VM exit occurs at the beginning of \xe2\x80\xa6CiThis control determines whether executions of MONITOR \xe2\x80\xa6CnIf this control is 1, non-maskable interrupts (NMIs) cause \xe2\x80\xa6BbList of error codes on page fault.CmIf the \xe2\x80\x9cEPT-violation #VE\xe2\x80\x9d VM-execution control is 1, \xe2\x80\xa6CeTable 24-13. Definitions of Primary VM-Exit Controls.AeX2Apic internal stateAjInterrupt 30 - Reserved10.AjInterrupt 31 - Reserved11.BbFurther specifies the ABI version.BnSize of a program header table entry in bytes.BnSize of a section header table entry in bytes.BnResolve the exit reason of the activated vmcs.B`Forward to the next instruction.ChGet a reference of page directory pointed by this entry.CdGet a reference of page table pointed by this entry.BjInterrupt 10 - Invalid TSS Exception (#TS)oResum the vcpu.BjInterrupt 12 - Stack Fault Exception (#SS)C`This control determines whether the tertiary \xe2\x80\xa6CnThis control determines whether executions of MOV from CR8 \xe2\x80\xa6ClThis control determines whether the logical processor is \xe2\x80\xa6AoFailed on vmlaunch or vmresume.CmTable 28-3. Format of an EPT Page-Directory-Pointer-Table \xe2\x80\xa6BgTrait that represent the hypercall abi.AbHypercall context.AlThe Vmstate of NoEptVmState.BoIterator over program headers in an ELF binary.B`A table for segment descriptors.CeThis control determines whether executions of I/O \xe2\x80\xa6CcIf the \xe2\x80\x9cmode-based execute control for EPT\xe2\x80\x9d \xe2\x80\xa600ClSetting this control to 1 enables TPR virtualization and \xe2\x80\xa6BfInterrupt 32 - User Defined Interrupt0BfInterrupt 33 - User Defined Interrupt1BfInterrupt 34 - User Defined Interrupt2BfInterrupt 35 - User Defined Interrupt3BfInterrupt 36 - User Defined Interrupt4BfInterrupt 37 - User Defined Interrupt5BfInterrupt 38 - User Defined Interrupt6BfInterrupt 39 - User Defined Interrupt7BfInterrupt 40 - User Defined Interrupt8BfInterrupt 41 - User Defined Interrupt9ChIf this control is 1, NMIs are never blocked and the \xe2\x80\xa6BdA possible status of sVirtIO device.BnTable 24-15. Definitions of VM-Entry Controls.AnPossible result of the Vmexit.CjWhen set, the page fault was caused by a write access. \xe2\x80\xa6AfAdds the set of flags.0000000000000BjInterrupt 0 - Divide Error Exception (#DE)BjInterrupt 8 - Double Fault Exception (#DF)AjSetup the page for mbinfo.DgReturns the intersection between the flags in <code>self</code> and \xe2\x80\xa60000000000000CnGet a reference of page directory pointer table pointed by \xe2\x80\xa6oProject0: KeOS.AlProject 1: VMCS and VMExits.BcProject 3: Hardware Virtualization.BlProject 4: Interrupt and I/O virtualization.AhProject 5: Final projectBeGet enabled pin-based control fields.mSegmentation.CcInterrupt 32 ~ 255 - User Defined Interrupt 0 ~ 223mVCPU threads.CkThis control determines whether the IA32_LBR_CTL MSR is \xe2\x80\xa6CkIf this control is 0, any execution of RDTSCP causes an \xe2\x80\xa6ChTable 28-1. Format of an EPT PML4 Entry (PML4E) that \xe2\x80\xa6AaType of exceptionAdMSR - IA32_VMX_MISC.BlInterrupt 6 - Invalid Opcode Exception (#UD)BjThe decoded information of io instruction.AgVm Pager of the kernel.CnThis control determines whether the IA32_PAT MSR is loaded \xe2\x80\xa60CmThis control determines whether the IA32_PAT MSR is saved \xe2\x80\xa6AnA unique kernel segment table.BhX86_64\xe2\x80\x99s access permission of segment.BgInterrupt 42 - User Defined Interrupt10BgInterrupt 43 - User Defined Interrupt11BgInterrupt 44 - User Defined Interrupt12BgInterrupt 45 - User Defined Interrupt13BgInterrupt 46 - User Defined Interrupt14BgInterrupt 47 - User Defined Interrupt15BgInterrupt 48 - User Defined Interrupt16BgInterrupt 49 - User Defined Interrupt17BgInterrupt 50 - User Defined Interrupt18BgInterrupt 51 - User Defined Interrupt19BgInterrupt 52 - User Defined Interrupt20BgInterrupt 53 - User Defined Interrupt21BgInterrupt 54 - User Defined Interrupt22BgInterrupt 55 - User Defined Interrupt23BgInterrupt 56 - User Defined Interrupt24BgInterrupt 57 - User Defined Interrupt25BgInterrupt 58 - User Defined Interrupt26BgInterrupt 59 - User Defined Interrupt27BgInterrupt 60 - User Defined Interrupt28BgInterrupt 61 - User Defined Interrupt29BgInterrupt 62 - User Defined Interrupt30BgInterrupt 63 - User Defined Interrupt31BgInterrupt 64 - User Defined Interrupt32BgInterrupt 65 - User Defined Interrupt33BgInterrupt 66 - User Defined Interrupt34BgInterrupt 67 - User Defined Interrupt35BgInterrupt 68 - User Defined Interrupt36BgInterrupt 69 - User Defined Interrupt37BgInterrupt 70 - User Defined Interrupt38BgInterrupt 71 - User Defined Interrupt39BgInterrupt 72 - User Defined Interrupt40BgInterrupt 73 - User Defined Interrupt41BgInterrupt 74 - User Defined Interrupt42BgInterrupt 75 - User Defined Interrupt43BgInterrupt 76 - User Defined Interrupt44BgInterrupt 77 - User Defined Interrupt45BgInterrupt 78 - User Defined Interrupt46BgInterrupt 79 - User Defined Interrupt47BgInterrupt 80 - User Defined Interrupt48BgInterrupt 81 - User Defined Interrupt49BgInterrupt 82 - User Defined Interrupt50BgInterrupt 83 - User Defined Interrupt51BgInterrupt 84 - User Defined Interrupt52BgInterrupt 85 - User Defined Interrupt53BgInterrupt 86 - User Defined Interrupt54BgInterrupt 87 - User Defined Interrupt55BgInterrupt 88 - User Defined Interrupt56BgInterrupt 89 - User Defined Interrupt57BgInterrupt 90 - User Defined Interrupt58BgInterrupt 91 - User Defined Interrupt59BgInterrupt 92 - User Defined Interrupt60BgInterrupt 93 - User Defined Interrupt61BgInterrupt 94 - User Defined Interrupt62BgInterrupt 95 - User Defined Interrupt63BgInterrupt 96 - User Defined Interrupt64BgInterrupt 97 - User Defined Interrupt65BgInterrupt 98 - User Defined Interrupt66BgInterrupt 99 - User Defined Interrupt67BhInterrupt 100 - User Defined Interrupt68BhInterrupt 101 - User Defined Interrupt69BhInterrupt 102 - User Defined Interrupt70BhInterrupt 103 - User Defined Interrupt71BhInterrupt 104 - User Defined Interrupt72BhInterrupt 105 - User Defined Interrupt73BhInterrupt 106 - User Defined Interrupt74BhInterrupt 107 - User Defined Interrupt75BhInterrupt 108 - User Defined Interrupt76BhInterrupt 109 - User Defined Interrupt77BhInterrupt 110 - User Defined Interrupt78BhInterrupt 111 - User Defined Interrupt79BhInterrupt 112 - User Defined Interrupt80BhInterrupt 113 - User Defined Interrupt81BhInterrupt 114 - User Defined Interrupt82BhInterrupt 115 - User Defined Interrupt83BhInterrupt 116 - User Defined Interrupt84BhInterrupt 117 - User Defined Interrupt85BhInterrupt 118 - User Defined Interrupt86BhInterrupt 119 - User Defined Interrupt87BhInterrupt 120 - User Defined Interrupt88BhInterrupt 121 - User Defined Interrupt89BhInterrupt 122 - User Defined Interrupt90BhInterrupt 123 - User Defined Interrupt91BhInterrupt 124 - User Defined Interrupt92BhInterrupt 125 - User Defined Interrupt93BhInterrupt 126 - User Defined Interrupt94BhInterrupt 127 - User Defined Interrupt95BhInterrupt 128 - User Defined Interrupt96BhInterrupt 129 - User Defined Interrupt97BhInterrupt 130 - User Defined Interrupt98BhInterrupt 131 - User Defined Interrupt99BgDisables all flags disabled in the set.0000000000000AiToggles the set of flags.0000000000000AoHandle the vmexit on this vcpu.BgAttach a mmio page at <code>gpa</code>.AkSystem Power RAW Operation.BfGet enabled proc-based control fields.BmUpper 32bit of the virtqueue physical addressBmLower 32bit of the virtqueue physical addressBlVirtual machine configuration of project3-1.AcSimple VirtIO BlockCkIf this control is 0, any execution of INVPCID causes a \xe2\x80\xa6CkIf this control is 0, any execution of PCONFIG causes a \xe2\x80\xa6AdMSR - IA32_VMX_BASICClThis control determines whether CET-related MSRs and SPP \xe2\x80\xa60CmThis control determines whether DR7 and the IA32_DEBUGCTL \xe2\x80\xa6ChThis control determines whether the IA32_EFER MSR is \xe2\x80\xa60AoThe Vcpu state of NoEptVmState.AaPrivilege Levels.CnThis control determines whether executions of RDRAND cause \xe2\x80\xa6CnThis control determines whether executions of RDSEED cause \xe2\x80\xa6ChWhen set, one or more page directory entries contain \xe2\x80\xa6CnThis control determines whether the IA32_EFER MSR is saved \xe2\x80\xa6BiInterrupt 132 - User Defined Interrupt100BiInterrupt 133 - User Defined Interrupt101BiInterrupt 134 - User Defined Interrupt102BiInterrupt 135 - User Defined Interrupt103BiInterrupt 136 - User Defined Interrupt104BiInterrupt 137 - User Defined Interrupt105BiInterrupt 138 - User Defined Interrupt106BiInterrupt 139 - User Defined Interrupt107BiInterrupt 140 - User Defined Interrupt108BiInterrupt 141 - User Defined Interrupt109BiInterrupt 142 - User Defined Interrupt110BiInterrupt 143 - User Defined Interrupt111BiInterrupt 144 - User Defined Interrupt112BiInterrupt 145 - User Defined Interrupt113BiInterrupt 146 - User Defined Interrupt114BiInterrupt 147 - User Defined Interrupt115BiInterrupt 148 - User Defined Interrupt116BiInterrupt 149 - User Defined Interrupt117BiInterrupt 150 - User Defined Interrupt118BiInterrupt 151 - User Defined Interrupt119BiInterrupt 152 - User Defined Interrupt120BiInterrupt 153 - User Defined Interrupt121BiInterrupt 154 - User Defined Interrupt122BiInterrupt 155 - User Defined Interrupt123BiInterrupt 156 - User Defined Interrupt124BiInterrupt 157 - User Defined Interrupt125BiInterrupt 158 - User Defined Interrupt126BiInterrupt 159 - User Defined Interrupt127BiInterrupt 160 - User Defined Interrupt128BiInterrupt 161 - User Defined Interrupt129BiInterrupt 162 - User Defined Interrupt130BiInterrupt 163 - User Defined Interrupt131BiInterrupt 164 - User Defined Interrupt132BiInterrupt 165 - User Defined Interrupt133BiInterrupt 166 - User Defined Interrupt134BiInterrupt 167 - User Defined Interrupt135BiInterrupt 168 - User Defined Interrupt136BiInterrupt 169 - User Defined Interrupt137BiInterrupt 170 - User Defined Interrupt138BiInterrupt 171 - User Defined Interrupt139BiInterrupt 172 - User Defined Interrupt140BiInterrupt 173 - User Defined Interrupt141BiInterrupt 174 - User Defined Interrupt142BiInterrupt 175 - User Defined Interrupt143BiInterrupt 176 - User Defined Interrupt144BiInterrupt 177 - User Defined Interrupt145BiInterrupt 178 - User Defined Interrupt146BiInterrupt 179 - User Defined Interrupt147BiInterrupt 180 - User Defined Interrupt148BiInterrupt 181 - User Defined Interrupt149BiInterrupt 182 - User Defined Interrupt150BiInterrupt 183 - User Defined Interrupt151BiInterrupt 184 - User Defined Interrupt152BiInterrupt 185 - User Defined Interrupt153BiInterrupt 186 - User Defined Interrupt154BiInterrupt 187 - User Defined Interrupt155BiInterrupt 188 - User Defined Interrupt156BiInterrupt 189 - User Defined Interrupt157BiInterrupt 190 - User Defined Interrupt158BiInterrupt 191 - User Defined Interrupt159BiInterrupt 192 - User Defined Interrupt160BiInterrupt 193 - User Defined Interrupt161BiInterrupt 194 - User Defined Interrupt162BiInterrupt 195 - User Defined Interrupt163BiInterrupt 196 - User Defined Interrupt164BiInterrupt 197 - User Defined Interrupt165BiInterrupt 198 - User Defined Interrupt166BiInterrupt 199 - User Defined Interrupt167BiInterrupt 200 - User Defined Interrupt168BiInterrupt 201 - User Defined Interrupt169BiInterrupt 202 - User Defined Interrupt170BiInterrupt 203 - User Defined Interrupt171BiInterrupt 204 - User Defined Interrupt172BiInterrupt 205 - User Defined Interrupt173BiInterrupt 206 - User Defined Interrupt174BiInterrupt 207 - User Defined Interrupt175BiInterrupt 208 - User Defined Interrupt176BiInterrupt 209 - User Defined Interrupt177BiInterrupt 210 - User Defined Interrupt178BiInterrupt 211 - User Defined Interrupt179BiInterrupt 212 - User Defined Interrupt180BiInterrupt 213 - User Defined Interrupt181BiInterrupt 214 - User Defined Interrupt182BiInterrupt 215 - User Defined Interrupt183BiInterrupt 216 - User Defined Interrupt184BiInterrupt 217 - User Defined Interrupt185BiInterrupt 218 - User Defined Interrupt186BiInterrupt 219 - User Defined Interrupt187BiInterrupt 220 - User Defined Interrupt188BiInterrupt 221 - User Defined Interrupt189BiInterrupt 222 - User Defined Interrupt190BiInterrupt 223 - User Defined Interrupt191BiInterrupt 224 - User Defined Interrupt192BiInterrupt 225 - User Defined Interrupt193BiInterrupt 226 - User Defined Interrupt194BiInterrupt 227 - User Defined Interrupt195BiInterrupt 228 - User Defined Interrupt196BiInterrupt 229 - User Defined Interrupt197BiInterrupt 230 - User Defined Interrupt198BiInterrupt 231 - User Defined Interrupt199BiInterrupt 232 - User Defined Interrupt200BiInterrupt 233 - User Defined Interrupt201BiInterrupt 234 - User Defined Interrupt202BiInterrupt 235 - User Defined Interrupt203BiInterrupt 236 - User Defined Interrupt204BiInterrupt 237 - User Defined Interrupt205BiInterrupt 238 - User Defined Interrupt206BiInterrupt 239 - User Defined Interrupt207BiInterrupt 240 - User Defined Interrupt208BiInterrupt 241 - User Defined Interrupt209BiInterrupt 242 - User Defined Interrupt210BiInterrupt 243 - User Defined Interrupt211BiInterrupt 244 - User Defined Interrupt212BiInterrupt 245 - User Defined Interrupt213BiInterrupt 246 - User Defined Interrupt214BiInterrupt 247 - User Defined Interrupt215BiInterrupt 248 - User Defined Interrupt216BiInterrupt 249 - User Defined Interrupt217BiInterrupt 250 - User Defined Interrupt218BiInterrupt 251 - User Defined Interrupt219BiInterrupt 252 - User Defined Interrupt220BiInterrupt 253 - User Defined Interrupt221BiInterrupt 254 - User Defined Interrupt222BiInterrupt 255 - User Defined Interrupt223CmIf this control is 1, executions of VMREAD and VMWRITE in \xe2\x80\xa6AkAn entry for the virtqueue.BdVMXON executed in VMX root operationClThis control determines whether executions of WBINVD and \xe2\x80\xa6BcVMWRITE to read-only VMCS componentBlInterrupt 6 - Invalid Opcode Exception (#UD)C`Get enabled proc-based secondary control fields.BgGet a virtual address of the virtqueue.BfPossible list of basic vmexit reasons.AdExit during the run.AiController-private error.AeEpt is not supported.BkException vector enumeration of the x86_64.AnExternal Interrupt InformationCmemulation of the device that prints the port &amp; direction.Ckemulation of the device that print the character of the \xe2\x80\xa6Cfemulation of device that tests all In/Out/Ins/Outs \xe2\x80\xa6CmThis control determines whether DR7 and the IA32_DEBUGCTL \xe2\x80\xa6BnX86_64\xe2\x80\x99s access permission of 64bit segment.AkX86_64\xe2\x80\x99s Segment RegisterAlX86_64\xe2\x80\x99s segment selector.ChThis control determines whether executions of RDTSC, \xe2\x80\xa6BeVMCALL executed in VMX root operationBkVirtual-machine eXtension is not supported.BeGet the instruction that rip pointed.CmGet a mutable reference of page directory pointed by this \xe2\x80\xa6CiGet a mutable reference of page table pointed by this \xe2\x80\xa6CiHandle the ept violation and load the corresponding page.CiThis control affects VM exits due to external interrupts:AnDouble fault Exception. Abort.CbIf this control is 1, EPT violations may cause \xe2\x80\xa6AiA visible state for VCpu.AcPage-Fault Handler.CjOn processors that support Intel 64 architecture, this \xe2\x80\xa6BlPossible errors for vm-related instructions.AbInterruption type.BjVM entry with invalid host-state field(s)2AiThe Vmstate of EptVmBase.Ai64bit task state segment.B`The header of the virtio device.BaFetcher object for the virtqueue.AjVMPTRLD with VMXON pointerAjVMCLEAR with VMXON pointerBiController that defines action on vmexit.AlError code is valid: BIT 11.BfAdd a exception bitmap to the builder.Biget basic exit reason of the exit reason.AkInitialize the guest state.BfInject interrupt to the VCpu with vec.DhInject the interrupt <code>vec</code> into the <code>active_vmcs</code>.CkGet a mutable reference of page directory pointer table \xe2\x80\xa6AiGet a virtqueue from Kva.BdEnable the VM-eXtension on this cpu.AhThe main loop of a VCpu.AoMachine Check Exception. Abort.ChSecond level page table that holds guest-physical to \xe2\x80\xa6CaInterrupt 13 - General Protection Exception (#GP)AnAlign Check Exception Handler.AcHardware exception.CiWhen set, the page fault was caused by an instruction \xe2\x80\xa6ClIf this control is 1, all output addresses used by Intel \xe2\x80\xa6AhVmx is disabled in bios.CkThis control determines whether the IA32_BNDCFGS MSR is \xe2\x80\xa6BfInterrupt 4 - Overflow Exception (#OF)AnX86_64\xe2\x80\x99s Segment Descriptor.BhInterrupt 11 - Segment Not Present (#NP)AjCommand for the virtqueue.AlVmcs operation has an error.AgVm operation has error.AkInterruption type: BIT 10~8CbInterrupt 5 - Bound Range Exceeded Exception (#BR)8CbInterrupt 7 - Device Not Available Exception (#NM)ClIf this control is 0, any execution of TPAUSE, UMONITOR, \xe2\x80\xa6AhFailed to handle vmexit.AiMSR - IA32_VMX_EXIT_CTLS.AiMSR - IA32_VMX_VMCS_ENUM.ClThis control determines whether the IA32_RTIT_CTL MSR is \xe2\x80\xa6CmThis control determines whether a series of executions of \xe2\x80\xa6AoThe Vcpu state of NoEptVmState.AcSoftware exception.CmThis control determines whether guest software may run in \xe2\x80\xa6BeVMPTRLD with invalid physical addressBeVMCLEAR with invalid physical addressClConvert from underlying bit representation, dropping any \xe2\x80\xa60000000000000CaInterrupt 13 - General Protection Exception (#GP)BfInterrupt 4 - Overflow Exception (#OF)Aipending interrupt bitmask:CjIf this control is 1, Intel Processor Trace suppresses \xe2\x80\xa6ChIf this control is 1, Intel Processor Trace does not \xe2\x80\xa60CgSetting this control to 1 enables use of the VMFUNC \xe2\x80\xa6AjMSR - IA32_VMX_CR0_FIXED0.AjMSR - IA32_VMX_CR0_FIXED1.AjMSR - IA32_VMX_CR4_FIXED0.AjMSR - IA32_VMX_CR4_FIXED1.AjMSR - IA32_VMX_ENTRY_CTLS.AiStack frame on interrupt.CnIf the \xe2\x80\x9cEPT paging-write control\xe2\x80\x9d VM-execution control \xe2\x80\xa6BdX86_64\xe2\x80\x99s 64bit Segment Descriptor.BaX86_64\xe2\x80\x99s system table register.CjVM entry with executive-VMCS pointer not VMXON pointer \xe2\x80\xa6AeVMRESUME after VMXOFFCnConvert from underlying bit representation, preserving all \xe2\x80\xa60000000000000BhInterrupt 11 - Segment Not Present (#NP)CiIf this control is 1, executions of ENCLS consult the \xe2\x80\xa6CiIf this control is 1, executions of ENCLV consult the \xe2\x80\xa6AkMSR - IA32_FEATURE_CONTROL.AgLocal descriptor table.BlInterrupt 2 - NonMaskableInterrupt InterruptCaVMREAD/VMWRITE from/to unsupported VMCS componentCbInterrupt 5 - Bound Range Exceeded Exception (#BR)CbInterrupt 7 - Device Not Available Exception (#NM)DkReturns the symmetric difference between the flags in <code>self</code> \xe2\x80\xa60000000000000ClIf this control is 0, any execution of XSAVES or XRSTORS \xe2\x80\xa6AhGlobal descriptor table.AlMSR - IA32_VMX_EPT_VPID_CAP.BlInterrupt 18 - Machine-Check Exception (#MC)CaError that occurs when page table mapping failed.AnPrivileged software exception.BjVMCALL with invalid VM-exit control fieldsCkTable 24-5. Definitions of Pin-Based VM-Execution Controls.BcNMI unblocking due to IRET: BIT 12.CaThis control determines whether the secondary \xe2\x80\xa6CiThis control determines whether the secondary VM-exit \xe2\x80\xa6AmMSR - IA32_VMX_PINBASED_CTLS.CkVMCALL with non-clear VMCS (when attempting to activate \xe2\x80\xa6CfTable 24-6. Definitions of Primary Processor-Based \xe2\x80\xa6ChVM entry with invalid VM-execution control fields in \xe2\x80\xa6BnInterrupt 17 - Alignment Check Exception (#AC)BeX86_64\xe2\x80\x99s general purpose registers.CjOn processors that support Intel 64 architecture, this \xe2\x80\xa6AeX86_64\xe2\x80\x99s IDT table.CkThis control determines whether the IA32_LBR_CTL MSR is \xe2\x80\xa6CnIf bit 7 of EPTP is 1, indicates whether supervisor shadow \xe2\x80\xa6CfIf this control is 1, the logical processor treats \xe2\x80\xa6BmInterrupt 20 - Virtualization Exception (#VE)CmVMCALL with invalid SMM-monitor features (when attempting \xe2\x80\xa6BlInterrupt 18 - Machine-Check Exception (#MC)CmThis control determines whether executions of LGDT, LIDT, \xe2\x80\xa6AmExit from vmx root operation.AoMSR - IA32_VMX_PROC_BASED_CTLS.AoTable of interrupt descriptors.CnIf this control is 1, the processor treats interrupts with \xe2\x80\xa6CcIf the \xe2\x80\x9csub-page write permissions for EPT\xe2\x80\x9d \xe2\x80\xa69AlVMLAUNCH with non-clear VMCSCaInterrupt 16 - x87 FPU Floating-Point Error (#MF):BiInterrupt 9 - Coprocessor Segment OverrunBeExit Qualification for EPT ViolationsAmFailed to decode instruction.B`MSR - IA32_VMX_PROC_BASED_CTLS2.ClThis control determines whether the IA32_PERF_GLOBAL_CTL \xe2\x80\xa6BoVMPTRLD with incorrect VMCS revision identifierBnInterrupt 17 - Alignment Check Exception (#AC)CmIf this control is 1, external interrupts cause VM exits. \xe2\x80\xa6CmThis control determines whether the IA32_PERF_GLOBAL_CTRL \xe2\x80\xa60CfIf this control is 1, EPT write permissions may be \xe2\x80\xa6CbInterrupt 19 - SIMD Floating-Point Exception (#XM)ChThis controls enables the evaluation and delivery of \xe2\x80\xa6CnIf this control is 1, the VMX-preemption timer counts down \xe2\x80\xa6CnIf this control is 1, EPT execute permissions are based on \xe2\x80\xa6BmVM entry with invalid executive-VMCS pointer2AoVMRESUME with non-launched VMCS?CkIf this control is 1, the logical processor virtualizes \xe2\x80\xa6ChVMCALL with incorrect MSEG revision identifier (when \xe2\x80\xa6CaInterrupt 16 - x87 FPU Floating-Point Error (#MF)BbInvalid operand to INVEPT/INVVPID.9BgVM entry with events blocked by MOV SS.CdThis control determines whether the value of the \xe2\x80\xa6BjVM entry with non-launched executive VMCS2ChTable 24-7. Definitions of Secondary Processor-Based \xe2\x80\xa6CcVMXOFF under dual-monitor treatment of SMIs and SMMClIf set to 1, the default treatment of SMIs and SMM is in \xe2\x80\xa6ClHandler that push SegmentSelector as Error code. General \xe2\x80\xa6")