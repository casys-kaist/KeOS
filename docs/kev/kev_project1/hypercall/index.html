<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Hypercalls for project 2."><title>kev_project1::hypercall - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="kev_project1" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module hypercall</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../kev_project1/index.html">kev_<wbr>project1</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module hypercall</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#hypercall-interface" title="Hypercall interface">Hypercall interface</a></li><li><a href="#tasks" title="Tasks">Tasks</a></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate kev_<wbr>project1</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">kev_project1</a></div><h1>Module <span>hypercall</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/kev_project1/hypercall.rs.html#1-102">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Hypercalls for project 2.</p>
<p>Hypercall is a software trap from the guest operating system to hypervisor,
similar to the syscall from the application to kernel. You can simply think
hypercall as a “syscall” of the hypervisor and guest OS.</p>
<p>In x86_64, guest OS can requests hypercall through the special instruction
“vmcall”. When guest OS executes “vmcall” instruction, it first vmexits to
the hypervisor. After that, hypercall reads the registers and resolve the
requested hypercall according to the its own abi for hypercall.
And the hypervisor serves the requests and pass the control back to the
guest OS through the “vmresume” instruction.</p>
<p>Both the project now and the project afterwards, you will use the following
abis for hypercall. %rax holds the hypercall number.
%rdi, %rsi, %rdx, %r10, %r9, %r8 are the first and second arguments, and so
on.</p>
<h3 id="hypercall-interface"><a class="doc-anchor" href="#hypercall-interface">§</a>Hypercall interface</h3>
<p>The core interface of hypercall is <a href="../vmexit/hypercall/trait.HypercallAbi.html" title="trait kev_project1::vmexit::hypercall::HypercallAbi"><code>HypercallAbi</code></a> and <a href="../vmexit/hypercall/trait.Hypercall.html" title="trait kev_project1::vmexit::hypercall::Hypercall"><code>Hypercall</code></a>
traits. When the vcpu executes the vmcall, it traps into the vmexit handler
of the host operating system. Then the vmexit control infrastructure of the
kev forwards the given request to the <a href="../vmexit/hypercall/struct.Controller.html" title="struct kev_project1::vmexit::hypercall::Controller"><code>Controller</code></a> for the hypercall. When
the <a href="../vmexit/hypercall/struct.Controller.html" title="struct kev_project1::vmexit::hypercall::Controller"><code>Controller</code></a> found that the given request is a hypercall, it probes
the CPU state and resolve the information of the request through the
<a href="../vmexit/hypercall/trait.Hypercall.html#tymethod.resolve" title="associated function kev_project1::vmexit::hypercall::Hypercall::resolve"><code>Hypercall::resolve</code></a>. After that the <a href="../vmexit/hypercall/struct.Controller.html" title="struct kev_project1::vmexit::hypercall::Controller"><code>Controller</code></a> passes the decoded
hypercall request to the <a href="../vmexit/hypercall/trait.HypercallAbi.html#tymethod.handle" title="method kev_project1::vmexit::hypercall::HypercallAbi::handle"><code>HypercallAbi::handle</code></a>. The
<a href="../vmexit/hypercall/trait.HypercallAbi.html#tymethod.handle" title="method kev_project1::vmexit::hypercall::HypercallAbi::handle"><code>HypercallAbi::handle</code></a> then finally handles the given requests.</p>
<h3 id="tasks"><a class="doc-anchor" href="#tasks">§</a>Tasks</h3>
<p>For this part, you are required to implement two hypercalls: the first halts
the current vCPU, while the second prints a string to the console.
The detailed Application Binary Interface (ABI) for each hypercall can be
founded in the <a href="../vmexit/hypercall/trait.Hypercall.html" title="trait kev_project1::vmexit::hypercall::Hypercall"><code>Hypercall</code></a> code section. When you write to the console,
you <strong>MUST</strong> proxy the console output through the [<code>PrinterProxy</code>].
Otherwise, grading script may be failed.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.HypercallCtx.html" title="struct kev_project1::hypercall::HypercallCtx">Hypercall<wbr>Ctx</a></dt><dd>Hypercall context.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Hypercall.html" title="enum kev_project1::hypercall::Hypercall">Hypercall</a></dt><dd>Supported hypercalls.</dd></dl></section></div></main></body></html>