<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Project 1: VMCS and VMExits."><title>kev_project1 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="kev_project1" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate kev_project1</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../kev_project1/index.html">kev_<wbr>project1</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#background" title="Background">Background</a><ul><li><a href="#virtual-machine" title="Virtual machine">Virtual machine</a></li><li><a href="#vm-exit" title="VM Exit">VM Exit</a></li><li><a href="#virtual-machine-control-data-structure-intel-vmx" title="Virtual Machine Control data Structure (Intel VMX)">Virtual Machine Control data Structure (Intel VMX)</a></li></ul></li><li><a href="#kev" title="KeV">KeV</a><ul><li><a href="#vm" title="Vm">Vm</a></li><li><a href="#vcpu" title="VCpu">VCpu</a></li><li><a href="#guest-memory-abstraction" title="Guest Memory Abstraction">Guest Memory Abstraction</a></li><li><a href="#vmexitcontroller" title="VmexitController">VmexitController</a></li></ul></li><li><a href="#getting-started" title="Getting started">Getting started</a></li><li><a href="#outline" title="Outline">Outline</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>kev_<wbr>project1</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/kev_project1/lib.rs.html#1-218">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Project 1: VMCS and VMExits.</p>
<p>In the first project, you will implement the basic building blocks of the
virtualization. Although the hardware-based virtualization gives a safe and
convinient way to support virtualize the machine, it is not a perfect tool.</p>
<p>Some less-frequently used and safety sensitive operations are required to be
trap-and-emulated. Examples of such sensitive instructions include cpuid,
port-mapped I/O, and memory-mmaped I/O.</p>
<p>Some operations have high cost to trap-and-emulate multiple steps, they are
optimization that combines multiple operations into a single operation
called hypercall.</p>
<p>You will learn about multiple trap-and-emulate operations by implementing a
simple print function in three different ways: hypercall, port-mapped I/O
and memory-mapped I/O. In project2, you will play on first two, hypercall
and port-mapped I/O.</p>
<p>Also, you will learn the concepts of instruction emulation.
Some instructions (e.g. cpuid, rdmsr, wrmsr) are sensitive to run directly
on guest cpu or required some modifications. The VMM requires to
trap-and-emulate those instructions.</p>
<p>While hands-on the project, you will become familiar with kev’s
infrastructure and the concepts of VMCS and VMExit.</p>
<h3 id="background"><a class="doc-anchor" href="#background">§</a>Background</h3><h4 id="virtual-machine"><a class="doc-anchor" href="#virtual-machine">§</a>Virtual machine</h4>
<p>A virtual machine is an physical computer system that provides virtualized
hardware resources. The virtual resources, such as CPU, memory, storage, and
network interfaces, are presented to guest operating systems and
applications as if they were physically present. By running on top of a
virtual machine, normal programs and operating systems can be executed using
these virtual resources.</p>
<p>Multiple virtual machines can be operated on a single physical machine,
and the distribution of physical resources to virtual machines is managed by
a software layer called a Virtual Machine Monitor (VMM), also known as a
Hypervisor. The VMM provides a layer of abstraction between the virtual
machines and the underlying physical hardware, enabling physical resources
to be shared among all VMs. Each VM environment is isolated from other VMs,
so they do not know about each other and are unaware that they are
controlled by the VMM.</p>
<p>Modern CPU architectures, such as those from Intel and AMD, provide hardware
virtualization support that enables system engineers to design custom
virtual machine environments. By utilizing hardware-assisted virtualization,
guest virtual machines can securely and efficiently access physical
resources provided by the host machine. In the KeV projects, we will
utilizes the Intel’s hardware virtualization, called Intel VM-eXtension
(Intel VMX).</p>
<h4 id="vm-exit"><a class="doc-anchor" href="#vm-exit">§</a>VM Exit</h4>
<p>Hardware virtualization is achieved by dividing the execution context into
two modes: host (VMX-root mode in Intel VMX) and guest (VMX-non-root mode in
Intel VMX). The VM Exit and VM Entry events facilitate mode switching
between these two contexts. When a virtual machine operation is executed in
non-root mode, certain sensitive instructions or events may trigger a VM
exit, which transfers control from the guest os context to the host os
context.</p>
<p>When a VM exit occurs, the VMM takes control and decides how to handle the
sensitive operation or event. The VMM may emulate the operation, modify the
operation to suit the virtualized environment, or defer the operation to the
underlying hardware. After the operation is handled, the VMM can choose to
resume execution in the non-root context.</p>
<h4 id="virtual-machine-control-data-structure-intel-vmx"><a class="doc-anchor" href="#virtual-machine-control-data-structure-intel-vmx">§</a>Virtual Machine Control data Structure (Intel VMX)</h4>
<p>Virtual machine control data structures (VMCS) are structures used by x86
during virtual machine execution. VMCS stores detailed information on how a
virtual machine will operate and its internal states, including its CPU and
memory, IO configurations, interrupt handling, and other hardware settings.</p>
<p>Virtual machine monitor (VMM) can control and read hardware features by
assigning difference VMCS to each virtual machine virtual processors.
For instance, a virtual machine with four virtual cores would use four VMCS
to control each core’s functionality.</p>
<p>To provide VMM with an abstract specification of the VMCS, which has
difference data structures across processor vendors and versions, hypervisor
access to VMCS is made through special instructions called <code>vmwrite</code> and
<code>vmread</code>. <code>vmwrite</code> writes to a specific field of the activated VMCS and
<code>vmread</code> reads a specific field of the activated VMCS. Therefore, x86
provides ways to access and distinguish which VMCS is currently being set by
the hypervisor. To this end, the VMCS states of Active, Current, and Clear
have been added. In this project, hardware and software details for VMCS
execution states and its associated instructions are hided from you.</p>
<h3 id="kev"><a class="doc-anchor" href="#kev">§</a>KeV</h3>
<p>KeV supplies a layer to abstraction to access the hardware-specific details.
It provides abstractions of Virtual Machine (<a href="../kev/vm/struct.Vm.html" title="struct kev::vm::Vm"><code>Vm</code></a>) and virtual CPU
(<a href="../kev/vcpu/struct.VCpu.html" title="struct kev::vcpu::VCpu"><code>VCpu</code></a>).</p>
<h4 id="vm"><a class="doc-anchor" href="#vm">§</a>Vm</h4>
<p>The <a href="../kev/vm/struct.Vm.html" title="struct kev::vm::Vm"><code>Vm</code></a> is an abstraction of a virtual machine. It contains multiple
virtual CPUs and its internal states. You can interact with the <a href="../kev/vm/struct.Vm.html" title="struct kev::vm::Vm"><code>Vm</code></a>
instance with the trait <a href="../kev/vm/trait.VmOps.html" title="trait kev::vm::VmOps"><code>VmOps</code></a>, which defines the mutiple operations of a
Virtual Machine. See the <a href="../kev/vm/trait.VmOps.html" title="trait kev::vm::VmOps"><code>VmOps</code></a> for list of the operations.</p>
<h4 id="vcpu"><a class="doc-anchor" href="#vcpu">§</a>VCpu</h4>
<p>The <a href="../kev/vcpu/struct.VCpu.html" title="struct kev::vcpu::VCpu"><code>VCpu</code></a> is an abstraction of a single virtual CPU. It holds the states
to run virtual CPU, including VMCS, general purpose registers, virtual CPU
ID, and VM Exit handlers. Each <a href="../kev/vcpu/struct.VCpu.html" title="struct kev::vcpu::VCpu"><code>VCpu</code></a> is an entity of scheudling. That is,
it is a basically a thread of a host operating system!</p>
<p>The VCpu thread runs in a loop that launch the VCpu, and handle the VM Exit.
In the loop, the thread launches the guest operating system through
<code>vmlaunch</code> or <code>vmresume</code>. After that, guest os traps back to the vmm by VM
Exit, it resolves the reason of the VM Exit, handles the VM Exit, and
returns back to the guest operating system. You can found the details of the
loop on <a href="../kev/vm/struct.Vm.html#method.vcpu_thread_work" title="associated function kev::vm::Vm::vcpu_thread_work"><code>Vm::vcpu_thread_work</code></a>.</p>
<h4 id="guest-memory-abstraction"><a class="doc-anchor" href="#guest-memory-abstraction">§</a>Guest Memory Abstraction</h4>
<p>With the introduction of the guest operating system, KeV brings two terms:
guest physical address (<a href="../kev/vm/struct.Gpa.html" title="struct kev::vm::Gpa"><code>Gpa</code></a>) and guest virtual addresss (<a href="../kev/vm/struct.Gva.html" title="struct kev::vm::Gva"><code>Gva</code></a>).</p>
<p>In project 2, all you need to mind is that there is no guest physical
address and guest virtual address is same as a host virtual address because
we are not introduce the memory virtualization yet. We will revisit this
topics in project 3 with memory virtualiation.</p>
<h4 id="vmexitcontroller"><a class="doc-anchor" href="#vmexitcontroller">§</a>VmexitController</h4>
<p>The <a href="../kev/vmexits/trait.VmexitController.html" title="trait kev::vmexits::VmexitController"><code>VmexitController</code></a> is the core interface to play with the VM Exits.
It is a trait define as follow:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>VmexitController {
   <span class="doccomment">/// Handle the vmexit on this controller.
   ///
   /// Returns [`VmError::HandleVmexitFailed`] when failed to handle vmexit on this controller.
   </span><span class="kw">fn </span>handle&lt;P: Probe&gt;(
       <span class="kw-2">&amp;mut </span><span class="self">self</span>,
       reason: ExitReason,
       p: <span class="kw-2">&amp;mut </span>P,
       generic_vcpu_state: <span class="kw-2">&amp;mut </span>GenericVCpuState,
   ) -&gt; <span class="prelude-ty">Result</span>&lt;VmexitResult, VmError&gt;;
}</code></pre></div>
<p>The VmexitController trait requires four arguments as input parameters</p>
<ul>
<li>&amp;mut self: Contains the self object of the given controller structure. You
can holds controller-specific states in <code>self</code>.</li>
<li>reason: Argument represents the <a href="../kev/vmcs/enum.ExitReason.html" title="enum kev::vmcs::ExitReason"><code>ExitReason</code></a> that holds the exit reasons
for the current vm exit. For instance, if the current vcpu is a hypercall,
the exit reasons would be <a href="../kev/vmcs/enum.BasicExitReason.html#variant.Vmcall" title="variant kev::vmcs::BasicExitReason::Vmcall"><code>BasicExitReason::Vmcall</code></a>.</li>
<li>p: <a href="../kev/probe/trait.Probe.html" title="trait kev::probe::Probe"><code>Probe</code></a> object that holds an information of memory state of the guest
operating system. You can use this object to translate address between
guest and host operating system.</li>
<li>generic_vcpu_state: Defines the states for the current vcpu. These states
comprise the current Virtual Machine Control Structure (VMCS), general
purpose registers (gen), and other relevant components which includes the
<a href="../kev/vm/trait.VmOps.html" title="trait kev::vm::VmOps"><code>VmOps</code></a>. See the <a href="../kev/vcpu/struct.GenericVCpuState.html" title="struct kev::vcpu::GenericVCpuState"><code>GenericVCpuState</code></a>.</li>
</ul>
<h5 id="activevmcs"><a class="doc-anchor" href="#activevmcs">§</a>ActiveVmcs</h5>
<p><a href="../kev/vmcs/struct.ActiveVmcs.html" title="struct kev::vmcs::ActiveVmcs"><code>ActiveVmcs</code></a> is an abstraction to communicate with the activated VMCS.
You can read or write to the activated VMCS with this struct.
This also defines multiple helper functions to modify the VMCS.</p>
<p>For instance,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="doccomment">/// Forward to the next instruction.
</span><span class="kw">pub fn </span>forward_rip(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Result</span>&lt;(), VmError&gt; {
   <span class="self">self</span>.write(
       Field::GuestRip,
       <span class="self">self</span>.read(Field::GuestRip)<span class="question-mark">? </span>+ <span class="self">self</span>.read(Field::VmexitInstructionLength)<span class="question-mark">?</span>,
   )
}</code></pre></div>
<p>The VMCS in this code (&amp;self) is capable of reading its internal fields to
read and write the RIP information necesasry for RIP forwarding. As like in
this example, you can read and write the VMCS structure for fetching
hardware informations of virtual machine in your KeV projects.</p>
<h3 id="getting-started"><a class="doc-anchor" href="#getting-started">§</a>Getting started</h3>
<p>When you run following command lines in the project2 directory, keos will be
panic with “not yet implemented” message.</p>
<div class="example-wrap"><pre class=""><code>$ cargo run --target ../.cargo/x86_64-unknown-keos.json</code></pre></div><h3 id="outline"><a class="doc-anchor" href="#outline">§</a>Outline</h3>
<ul>
<li><a href="no_ept_vm/index.html" title="mod kev_project1::no_ept_vm"><code>Virtual Machine Control Structure (VMCS)</code></a></li>
<li><a href="hypercall/index.html" title="mod kev_project1::hypercall"><code>Hypercall</code></a></li>
<li><a href="vmexit/pio"><code>Port-mapped I/O</code></a></li>
<li><a href="vmexit/cpuid"><code>Cpuid</code></a></li>
<li><a href="vmexit/msr"><code>Model-specific Register</code></a></li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="hypercall/index.html" title="mod kev_project1::hypercall">hypercall</a></dt><dd>Hypercalls for project 2.</dd><dt><a class="mod" href="msr/index.html" title="mod kev_project1::msr">msr</a></dt><dd>MSR handlers to test msr instructions correctly implemented.</dd><dt><a class="mod" href="no_ept_vm/index.html" title="mod kev_project1::no_ept_vm">no_<wbr>ept_<wbr>vm</a></dt><dd>Virtual machine control structure.</dd><dt><a class="mod" href="pio/index.html" title="mod kev_project1::pio">pio</a></dt><dd>Pio handlers to test pio instructions correctly implemented.</dd><dt><a class="mod" href="vmexit/index.html" title="mod kev_project1::vmexit">vmexit</a></dt><dd>Collections of vmexit controllers.</dd></dl></section></div></main></body></html>