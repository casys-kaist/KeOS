<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Synchronization primitives."><title>keos::sync - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="keos" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module sync</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../keos/index.html">keos</a><span class="version">1.0.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module sync</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#the-need-for-synchronization" title="The need for synchronization">The need for synchronization</a></li><li><a href="#higher-level-synchronization-objects" title="Higher-level synchronization objects">Higher-level synchronization objects</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate keos</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">keos</a></div><h1>Module <span>sync</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/keos/sync/mod.rs.html#1-87">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Synchronization primitives.</p>
<p>Support similar synchronization primitives like <code>std::sync</code>.</p>
<p>Belows sections is “copied” from <code>std::sync</code>’s documentation.</p>
<h3 id="the-need-for-synchronization"><a class="doc-anchor" href="#the-need-for-synchronization">§</a>The need for synchronization</h3>
<p>Conceptually, a Rust program is a series of operations which will
be executed on a computer. The timeline of events happening in the
program is consistent with the order of the operations in the code.</p>
<p>Consider the following code, operating on some global static variables:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">static </span><span class="kw-2">mut </span>A: u32 = <span class="number">0</span>;
<span class="kw">static </span><span class="kw-2">mut </span>B: u32 = <span class="number">0</span>;
<span class="kw">static </span><span class="kw-2">mut </span>C: u32 = <span class="number">0</span>;

<span class="kw">fn </span>main() {
    <span class="kw">unsafe </span>{
        A = <span class="number">3</span>;
        B = <span class="number">4</span>;
        A = A + B;
        C = B;
        <span class="macro">println!</span>(<span class="string">"{A} {B} {C}"</span>);
        C = A;
    }
}</code></pre></div>
<p>It appears as if some variables stored in memory are changed, an addition
is performed, result is stored in <code>A</code> and the variable <code>C</code> is
modified twice.</p>
<p>When only a single thread is involved, the results are as expected:
the line <code>7 4 4</code> gets printed.</p>
<p>As for what happens behind the scenes, when optimizations are enabled the
final generated machine code might look very different from the code:</p>
<ul>
<li>
<p>The first store to <code>C</code> might be moved before the store to <code>A</code> or <code>B</code>, <em>as
if</em> we had written <code>C = 4; A = 3; B = 4</code>.</p>
</li>
<li>
<p>Assignment of <code>A + B</code> to <code>A</code> might be removed, since the sum can be stored
in a temporary location until it gets printed, with the global variable
never getting updated.</p>
</li>
<li>
<p>The final result could be determined just by looking at the code at
compile time, so <a href="https://en.wikipedia.org/wiki/Constant_folding">constant folding</a> might turn the whole block into a
simple <code>println!("7 4 4")</code>.</p>
</li>
</ul>
<p>The compiler is allowed to perform any combination of these
optimizations, as long as the final optimized code, when executed,
produces the same results as the one without optimizations.</p>
<p>Due to the <a href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrency</a> involved in modern computers, assumptions
about the program’s execution order are often wrong. Access to
global variables can lead to nondeterministic results, <strong>even if</strong>
compiler optimizations are disabled, and it is <strong>still possible</strong>
to introduce synchronization bugs.</p>
<p>Note that thanks to Rust’s safety guarantees, accessing global (static)
variables requires <code>unsafe</code> code, assuming we don’t use any of the
synchronization primitives in this module.</p>
<h3 id="higher-level-synchronization-objects"><a class="doc-anchor" href="#higher-level-synchronization-objects">§</a>Higher-level synchronization objects</h3>
<p>Most of the low-level synchronization primitives are quite error-prone and
inconvenient to use, which is why the standard library also exposes some
higher-level synchronization objects.</p>
<p>These abstractions can be built out of lower-level primitives.
For efficiency, the sync objects in the standard library are usually
implemented with help from the operating system’s kernel, which is
able to reschedule the threads while they are blocked on acquiring
a lock.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt><code>pub use <a class="mod" href="rwlock/index.html" title="mod keos::sync::rwlock">rwlock</a>::*;</code></dt><dt><code>pub use <a class="mod" href="spinlock/index.html" title="mod keos::sync::spinlock">spinlock</a>::*;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="atomic/index.html" title="mod keos::sync::atomic">atomic</a></dt><dd>A wrapper around the core::sync::atomic.</dd><dt><a class="mod" href="rwlock/index.html" title="mod keos::sync::rwlock">rwlock</a></dt><dd>RwLock implementations.</dd><dt><a class="mod" href="spinlock/index.html" title="mod keos::sync::spinlock">spinlock</a></dt><dd>SMP-supported spinlock.</dd></dl></section></div></main></body></html>