<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A mutual exclusion primitive useful for protecting shared data"><title>SpinLock in keos::sync::spinlock - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="keos" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (07d246fc6 2025-08-31)" data-channel="nightly" data-search-js="search-449aa9bf.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">SpinLock</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../keos/index.html">keos</a><span class="version">1.0.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Spin<wbr>Lock</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#examples-1" title="Examples">Examples</a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield._pad" title="_pad">_pad</a></li><li><a href="#structfield.data" title="data">data</a></li><li><a href="#structfield.locked" title="locked">locked</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.into_inner" title="into_inner">into_inner</a></li><li><a href="#method.lock" title="lock">lock</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.try_lock" title="try_lock">try_lock</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Default-for-SpinLock%3CT%3E" title="Default">Default</a></li><li><a href="#impl-Send-for-SpinLock%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-SpinLock%3CT%3E" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-SpinLock%3CT%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-SpinLock%3CT%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-SpinLock%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-SpinLock%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In keos::<wbr>sync::<wbr>spinlock</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">keos</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">spinlock</a></div><h1>Struct <span class="struct">Spin<wbr>Lock</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/abyss/spinlock.rs.html#58">Source</a> </span></div><pre class="rust item-decl"><code>pub struct SpinLock&lt;T&gt;<div class="where">where
    T: ?Sized,</div>{
    locked: AtomicBool,
    _pad: [u8; 15],
    data: UnsafeCell&lt;T&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A mutual exclusion primitive useful for protecting shared data</p>
<p>This spinlock will block threads waiting for the lock to become available.
The spinlock can be created via a <a href="struct.SpinLock.html#method.new" title="associated function keos::sync::spinlock::SpinLock::new"><code>new</code></a> constructor. Each spinlock has a
type parameter which represents the data that it is protecting. The data can
only be accessed through the guards returned from <a href="struct.SpinLock.html#method.lock" title="method keos::sync::spinlock::SpinLock::lock"><code>lock</code></a> and
<a href="struct.SpinLock.html#method.try_lock" title="method keos::sync::spinlock::SpinLock::try_lock"><code>try_lock</code></a>, which guarantees that the data is only ever accessed when the
spinlock is locked.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;
<span class="kw">use </span>keos::sync::SpinLock;
<span class="kw">use </span>keos::thread;

<span class="kw">const </span>N: usize = <span class="number">10</span>;

<span class="comment">// Spawn a few threads to increment a shared variable (non-atomically), and
// let the main thread know once all increments are done.
//
// Here we're using an Arc to share memory among threads, and the data inside
// the Arc is protected with a spinlock.
</span><span class="kw">let </span>data = Arc::new(SpinLock::new(<span class="number">0</span>));

<span class="kw">for _ in </span><span class="number">0</span>..N {
    <span class="kw">let </span>data = Arc::clone(<span class="kw-2">&amp;</span>data);
    thread::ThreadBuilder::new(<span class="string">"work"</span>).spawn(<span class="kw">move </span>|| {
        <span class="comment">// The shared state can only be accessed once the lock is held.
        // Our non-atomic increment is safe because we're the only thread
        // which can access the shared state when the lock is held.
        //
        // We unwrap() the return value to assert that we are not expecting
        // threads to ever fail while holding the lock.
        </span><span class="kw">let </span><span class="kw-2">mut </span>data = data.lock().unwrap();
        <span class="kw-2">*</span>data += <span class="number">1</span>;
        <span class="comment">// the lock must be "explicitly" unlocked.
        </span>data.unlock();
    });
}</code></pre></div>
<p>A mutual exclusion primitive useful for protecting shared data</p>
<p>This spinlock will block threads waiting for the lock to become available.
The spinlock can be created via a <a href="struct.SpinLock.html#method.new" title="associated function keos::sync::spinlock::SpinLock::new"><code>new</code></a> constructor. Each spinlock has a
type parameter which represents the data that it is protecting. The data can
only be accessed through the guards returned from <a href="struct.SpinLock.html#method.lock" title="method keos::sync::spinlock::SpinLock::lock"><code>lock</code></a> and
<a href="struct.SpinLock.html#method.try_lock" title="method keos::sync::spinlock::SpinLock::try_lock"><code>try_lock</code></a>, which guarantees that the data is only ever accessed when the
spinlock is locked.</p>
<h2 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;
<span class="kw">use </span>keos::sync::SpinLock;
<span class="kw">use </span>keos::thread;

<span class="kw">const </span>N: usize = <span class="number">10</span>;

<span class="comment">// Spawn a few threads to increment a shared variable (non-atomically), and
// let the main thread know once all increments are done.
//
// Here we're using an Arc to share memory among threads, and the data inside
// the Arc is protected with a spinlock.
</span><span class="kw">let </span>data = Arc::new(SpinLock::new(<span class="number">0</span>));

<span class="kw">for _ in </span><span class="number">0</span>..N {
    <span class="kw">let </span>data = Arc::clone(<span class="kw-2">&amp;</span>data);
    thread::ThreadBuilder::new(<span class="string">"work"</span>).spawn(<span class="kw">move </span>|| {
        <span class="comment">// The shared state can only be accessed once the lock is held.
        // Our non-atomic increment is safe because we're the only thread
        // which can access the shared state when the lock is held.
        //
        // We unwrap() the return value to assert that we are not expecting
        // threads to ever fail while holding the lock.
        </span><span class="kw">let </span><span class="kw-2">mut </span>guard = data.lock();
        guard += <span class="number">1</span>;
        <span class="comment">// the lock must be "explicitly" unlocked before `guard` goes out of scope.
        </span>guard.unlock();
    });
}</code></pre></div>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.locked" class="structfield section-header"><a href="#structfield.locked" class="anchor field">§</a><code>locked: AtomicBool</code></span><span id="structfield._pad" class="structfield section-header"><a href="#structfield._pad" class="anchor field">§</a><code>_pad: [u8; 15]</code></span><span id="structfield.data" class="structfield section-header"><a href="#structfield.data" class="anchor field">§</a><code>data: UnsafeCell&lt;T&gt;</code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-SpinLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#67">Source</a><a href="#impl-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#78">Source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(t: T) -&gt; <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new spinlock in an unlocked state ready for use.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>keos::sync::SpinLock;

<span class="kw">let </span>spinlock = SpinLock::new(<span class="number">0</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SpinLock%3CT%3E-1" class="impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#87">Source</a><a href="#impl-SpinLock%3CT%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.lock" class="method"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#121">Source</a><h4 class="code-header">pub fn <a href="#method.lock" class="fn">lock</a>(&amp;self) -&gt; <a class="struct" href="struct.SpinLockGuard.html" title="struct keos::sync::spinlock::SpinLockGuard">SpinLockGuard</a>&lt;'_, T&gt;</h4></section></summary><div class="docblock"><p>Acquires a spinlock, blocking the current thread until it is able to do
so.</p>
<p>This function will block the local thread until it is available to
acquire the spinlock. Upon returning, the thread is the only thread
with the lock held. An guard is returned to allow scoped access
of the lock. When the guard goes out of scope without
<a href="struct.SpinLockGuard.html#method.unlock" title="method keos::sync::spinlock::SpinLockGuard::unlock"><code>SpinLockGuard::unlock</code></a>, panic occurs.</p>
<p>The exact behavior on locking a spinlock in the thread which already
holds the lock is left unspecified. However, this function will not
return on the second call (it might panic or deadlock, for example).</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>alloc::sync::Arc;
<span class="kw">use </span>keos::sync::SpinLock;
<span class="kw">use </span>keos::thread;

<span class="kw">let </span>spinlock = Arc::new(SpinLock::new(<span class="number">0</span>));
<span class="kw">let </span>c_spinlock = Arc::clone(<span class="kw-2">&amp;</span>spinlock);

thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span><span class="kw-2">mut </span>guard = c_spinlock.lock();
    <span class="kw-2">*</span>guard = <span class="number">10</span>;
    guard.unlock();
}).join().expect(<span class="string">"thread::spawn failed"</span>);
<span class="kw">let </span>guard = spinlock.lock();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>guard, <span class="number">10</span>);
guard.unlock();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_lock" class="method"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#175">Source</a><h4 class="code-header">pub fn <a href="#method.try_lock" class="fn">try_lock</a>(&amp;self) -&gt; Result&lt;<a class="struct" href="struct.SpinLockGuard.html" title="struct keos::sync::spinlock::SpinLockGuard">SpinLockGuard</a>&lt;'_, T&gt;, <a class="struct" href="struct.WouldBlock.html" title="struct keos::sync::spinlock::WouldBlock">WouldBlock</a>&gt;</h4></section></summary><div class="docblock"><p>Attempts to acquire this lock.</p>
<p>If the lock could not be acquired at this time, then [<code>Err</code>] is
returned. Otherwise, an guard is returned. The lock will be
unlocked when the guard is dropped.</p>
<p>This function does not block.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>If the spinlock could not be acquired because it is already locked, then
this call will return the <a href="struct.WouldBlock.html" title="struct keos::sync::spinlock::WouldBlock"><code>WouldBlock</code></a> error.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>keos::sync::SpinLock;
<span class="kw">use </span>alloc::sync::Arc;
<span class="kw">use </span>keos::thread;

<span class="kw">let </span>spinlock = Arc::new(SpinLock::new(<span class="number">0</span>));
<span class="kw">let </span>c_spinlock = Arc::clone(<span class="kw-2">&amp;</span>spinlock);

thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span><span class="kw-2">mut </span>lock = c_spinlock.try_lock();
    <span class="kw">if let </span><span class="prelude-val">Ok</span>(<span class="kw-2">ref mut </span>spinlock) = lock {
        <span class="kw-2">**</span>spinlock = <span class="number">10</span>;
    } <span class="kw">else </span>{
        <span class="macro">println!</span>(<span class="string">"try_lock failed"</span>);
    }
}).join().expect(<span class="string">"thread::spawn failed"</span>);
<span class="kw">let </span>guard = spinlock.lock();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>guard, <span class="number">10</span>);
guard.unlock();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#199-201">Source</a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>Consumes this spinlock, returning the underlying data.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>keos::sync::SpinLock;

<span class="kw">let </span>spinlock = SpinLock::new(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(spinlock.into_inner().unwrap(), <span class="number">0</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-SpinLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#207">Source</a><a href="#impl-Default-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Default for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: Default,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#209">Source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a class="fn">default</a>() -&gt; <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a <code>SpinLock&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>
</div></details></div></details><section id="impl-Send-for-SpinLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#64">Source</a><a href="#impl-Send-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Send for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: Send + ?Sized,</div></h3></section><section id="impl-Sync-for-SpinLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/abyss/spinlock.rs.html#65">Source</a><a href="#impl-Sync-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Sync for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: Send + ?Sized,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-SpinLock%3CT%3E" class="impl"><a href="#impl-Freeze-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !Freeze for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;</h3></section><section id="impl-RefUnwindSafe-for-SpinLock%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; !RefUnwindSafe for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;</h3></section><section id="impl-Unpin-for-SpinLock%3CT%3E" class="impl"><a href="#impl-Unpin-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Unpin for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: Unpin + ?Sized,</div></h3></section><section id="impl-UnwindSafe-for-SpinLock%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-SpinLock%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; UnwindSafe for <a class="struct" href="struct.SpinLock.html" title="struct keos::sync::spinlock::SpinLock">SpinLock</a>&lt;T&gt;<div class="where">where
    T: UnwindSafe + ?Sized,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>